{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyMoe","text":"<p>Welcome to PyMoe. PyMoe is a general purpose Python library that wraps APIs for several large websites that offer information about Anime, Manga, Light Novels, and Web Novels. Currently six different APIs are supported with plans for more in the future (Especially looking at MangaDex integration).</p> <ul> <li> <p> Supports Several APIs</p> <ul> <li>Anilist</li> <li>MyAnimeList</li> <li>Kitsu</li> <li>Mangaupdates</li> <li>WLNUpdates</li> <li>Bakatsuki</li> </ul> </li> <li> <p> Simple and Expressive</p> <p>This library ships with custom API aware iterators. Every function that returns multiple results returns a generator. This simplifies code and means that this is a valid code segment.</p> <pre><code>for item in pymoe.anime.search.shows(\"Toradora\"):\n    print(item)\n</code></pre> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Versioning</p> <p>Keep in mind that PyMoe currently has a legacy version. The legacy version is 1.0.6 and exists only to not break applications written under that version. It is vastly different from the current version which is 2.*. The biggest difference is the unification of the internal API.</p> <p>Installing PyMoe is easy. You have several options depending on your needs, though the recommended path is to use a project manager like Poetry or Hatch. Barring that, you can install it using pipx which automatically sandboxes your pip into isolated environments. You can install it using the pip shipped with your python installation, however this is not the recommended path as you typically want your primary python environment to remain clean.</p> <ul> <li> <p>pipx</p> <pre><code>pipx install pymoe\n</code></pre> <p>Or to install legacy... <pre><code>pipx install pymoe==1.0.6\n</code></pre></p> </li> <li> <p>Poetry</p> <p>In pyproject.toml</p> <pre><code>pymoe = \"*\"\n</code></pre> <p>Or to prevent unnecessary breakage... <pre><code>pymoe = \"2.2.*\"\n</code></pre></p> <p>Or to install legacy... <pre><code>pymoe = \"1.0.6\"\n</code></pre></p> </li> <li> <p>Hatch</p> <p>In pyproject.toml</p> <pre><code>dependencies = [\n    \"pymoe\"\n]\n</code></pre> <p>Or to prevent unnecessary breakage... <pre><code>dependencies = [\n    \"pymoe==2.2.*\"\n]\n</code></pre></p> <p>Or to install legacy... <pre><code>dependencies = [\n    \"pymoe==1.0.6\"\n]\n</code></pre></p> </li> <li> <p>The Not Recommended Way</p> <pre><code>pip install pymoe\n</code></pre> <p>Or to install legacy... <pre><code>pip install pymoe==1.0.6\n</code></pre></p> </li> </ul>"},{"location":"#further-reading","title":"Further Reading","text":"<p>Now that you have PyMoe properly installed and linked, you'll want to get using it. Depending on your level of experience in python, the documentation is spread out across several files written in different ways.</p> <ul> <li> <p>If you are new to the library, I would recommend starting at the User Guide. This covers basic usage across all of the library and more specific details for each implementation. </p> </li> <li> <p>If you just want a quick overview of the library then please read the section below.</p> </li> <li> <p>If you just want to see some examples then you can find those at Examples.</p> </li> <li> <p>If you instead want to see code documentation, you can either see Github or read the autogenerated documentation at Autogenerated. </p> </li> <li> <p>Finally, if you want to build PyMoe from source, then take a look at Building which covers how the build pipeline is setup for this project.</p> </li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>Once installed, the basic operation of the library is to import pymoe and then use the modules you need. You can also just import specific modules if you only need one data type. There are a few quick examples below.</p> <p>Default Providers</p> <p>It's important that you are aware of the default providers across each module. You can of course use only the specific service you want, but these are the services used when you use the top level functions in pymoe.type.operation.endpoint. These providers are Anilist for Anime and Manga and WLNUpdates for LN.</p> <p></p>"},{"location":"#importing","title":"Importing","text":"<pre><code># The whole thing\n# All the examples are written around this kind of import\nimport pymoe\n\n# Custom named import\nimport pymoe as owu\n\n# Just the anime module\nfrom pymoe import anime\n\n# This one is probably not so useful, but it only allows you to use anilist get endpoints\nfrom pymoe.anime.get import anilist\n\n# For when you really don't want to keep typing pymoe.anime.search\npyref = pymoe.anime.search\n# Now we can just...\npyref.shows(\"Toradora\")\n\n# Or you could do say\nfrom pymoe import anime as pyani\n# And then just...\npyani.search.shows(\"Toradora\")\n</code></pre>"},{"location":"#basic-usage-searching","title":"Basic Usage - Searching","text":"<pre><code>import pymoe\n\n# Print information about each item returned in the search\nfor item in pymoe.anime.search.shows(\"Toradora\"):\n    print(item)\n\n# Maybe you want manga instead\nfor item in pymoe.manga.search.manga(\"Toradora\"):\n    print(item)\n\n# Now you want novels?\nfor item in pymoe.ln.search.series(\"Toradora\"):\n    print(item)\n</code></pre>"},{"location":"#basic-usage-getting-items-by-id","title":"Basic Usage - Getting items by ID","text":"<p>MangaUpdates IDs</p> <p>A quick warning about the IDs for MangaUpdates. If you were to search for the series Slam Dunk on their website you would end up at https://www.mangaupdates.com/series/pklldyu/slam-dunk. However, do not be fooled. pklldyu is NOT the ID you use with the API. This is a Base36Encoded ID used for the website. You'll need to decode the ID to 55665151734 which is the proper ID for Slam Dunk in the API. There is a helper function for this at <code>pymoe.utils.helpers.base36Decode</code>. You can also just call <code>int(string, 36)</code> from your code.</p> <pre><code>import pymoe\n\n# Print information about Anilist Show ID 154587\n# This show is Frieren: Beyond Journey\u2019s End\nprint(pymoe.anime.get.show(154587))\n\n# For Manga information from Anilist Manga ID 97722\n# This manga is Yami ni Hau Mono Lovecraft Kessakushuu\nprint(pymoe.manga.get.manga(97722))\n\n# For LN information from WLNUpdates\n# This is the novel Death March kara Hajimaru Isekai Kyusoukyoku\nprint(pymoe.ln.get.series(581))\n\n# To reinforce the warning, this is the series Slam Dunk from MangaUpdates\nprint(pymoe.manga.get.mangaupdates.series(55665151734))\n</code></pre>"},{"location":"#advanced-usage-specific-services","title":"Advanced Usage - Specific Services","text":"<p>If you want to use specific services then you can call them as pymoe.type.operation.service.endpoint. For example, <code>pymoe.ln.search.wlnupdates.series</code>.</p> <pre><code>import pymoe\n\n# Specifically Anilist\n# This is Frieren: Beyond Journey's End as above\npymoe.anime.get.anilist.show(154587)\n\n# Specifically kitsu\n# This is also Frieren: Beyond Journey's End\npymoe.anime.get.kitsu.show(46474)\n</code></pre> <p>The services available for each type are listed below.</p> <p>A Note About Kitsu</p> <p>You should know that Kitsu is not supported long term. They intend to redo their API and move to Algolia for searching. Algolia has their own libraries and requires developer registration on their website to use the search endpoints. GET endpoints should continue to work as they already do, however there will come a point when this library no longer supports searching at Kitsu. I have no intention of removing GET endpoints as long as they continue to work.</p> Type Services <code>ANIME</code> Anilist, MAL, Kitsu <code>MANGA</code> Anilist, Kitsu, MangaUpdates <code>LN</code> Bakatsuki, WLNUpdates"},{"location":"#expert-usage-just-some-pattern-discussion","title":"Expert Usage - Just Some Pattern Discussion","text":"<p>This section is optional. It goes over a few notes that developers might be interested in and the ways I would work around the library.</p> <p>If I didn't want to keep typing pymoe.type.operation.service.endpoint I would probably... <pre><code>import pymoe\n\n# Make a Tuple\nANILIST = (pymoe.anime.get.anilist, pymoe.anime.search.anilist)\n# Then I can just\nANILIST[0].show(154587)\n\n# Or Maybe Make a dictionary\nANILIST = {\n    'get': pymoe.anime.get.anilist,\n    'search': pymoe.anime.search.anilist\n}\n# Then I can just\nANILIST['get'].show(154587)\n</code></pre></p> <p>User-Agents</p> <p>There is no easy way to change the User-Agent used across the entire library. Each module has its own settings and by extension its own User-Agents. This means you can manually control the User-Agent sent to each service, but does also mean there's more work upfront to change them.</p> <p>If I wanted to change the user-agent, then I would... <pre><code>import pymoe\n\n# This example is the same for all the modules\n# Let's make our tuple again\nANILIST = (pymoe.anime.get.anilist, pymoe.anime.search.anilist)\n\n# Now change our user-agent\nfor x in ANILIST:\n    x.settings['header']['User-Agent'] = \"My Cool App (github.com/mysupername/mycoolapp\"\n\n# For another extra example, let's do MangaUpdates\nMANGAU = (pymoe.manga.get.mangaupdates, pymoe.manga.search.mangaupdates)\nfor x in MANGAU:\n    x.settings['header']['User-Agent'] = \"My Cool App (github.com/mysupername/mycoolapp\"\n</code></pre></p> <p>If you need to see how different services return different data, then I would take a look at the testing suites under tests. I intentionally extract the data out as needed both for ease of code writing and also to show how the data is nested on return.</p>"},{"location":"#rate-limits","title":"Rate Limits","text":"<p>While this library does not directly manage Rate Limiting, I do try to give you all the tools to do so on your own. First, let's go over how each service handles rate limiting.</p> Service Rate Limiting Methods <code>ANILIST</code> Headers and 429s, 90 Requests per Minute <code>MYANIMELIST</code> No Documentation, May Not Even Exist <code>KITSU</code> No Documentation <code>WLNUPDATES</code> JSON Object. 'Error' is True and 'Message' has rate limited <code>MANGAUPDATES</code> 412 for Rate Limited, 429 for Cloudflare <code>BAKATSUKI</code> ratelimited in return text <p>At the moment, my intention is to add returning headers along with the requested data into the library. However, any method I might use to do that would be a breaking change so this will likely not happen until a 3.0 version comes around. For now, you can check for status code 429 in the ServerError raised when Anilist encounters a 429. You can do the same for MangaUpdates which returns 412 for Rate Limiting or 429 for Cloudflare blocked. Bakatsuki and WLNUpdates are a bit easier. You can simply search for the phrase 'ratelimited' or 'rate limited' in the return text. As for MyAnimeList or Kitsu, there's absolutely no information I can give you, but if you ever do hit some kind of rate limit or 429 from one of those services, feel free to open up an issue at the github so I can add it to the documentation and plan to react to it in the future.</p> <p>For now, my overall suggestion would be to add short breaks between each call if you're doing batch processes. Even just 0.5 seconds will likely prevent you from hitting a rate limit. Here is an example of both catching the error and a slight pause between requests.</p> <pre><code>import time\nimport pymoe\n\nresult = None\n\ntry:\n    result = pymoe.manga.get.manga(30002)\nexcept pymoe.utils.errors.serverError as ex:\n    # Assuming a 429, this would print: Failed. Got 429.\n    print(\"Failed. Got {}.\".format(ex.code))\nelse:\n    print(result)\n\n# For a slight pause, assuming results is a list of character IDs\nfor item in results:\n    print(pymoe.manga.get.character(item))\n    # DO NOT DO THIS IN AN ASYNC LOOP. \n    # USE ASYNCIO.TIME OR THE EQUIVALENT FOR YOUR PARTICULAR LOOP ENGINE.\n    time.sleep(0.5)\n</code></pre>"},{"location":"#asynchronous-operation","title":"Asynchronous Operation","text":"<p>This library wasn't specifically built for asynchronous work though I would welcome a push request to a new branch. That being said, this code doesn't do anything that would be thread unsafe. It is literally a wrapper around web requests. So you can absolutely throw it into asynch code using threads or asyncio.executor and it shouldn't do anything that will mess you up.</p>"},{"location":"autogenerated/","title":"Autogenerated Documentation","text":"<p>This is a listing of the documentation autogenerated by mkdocstrings from the comments in my code. The autogenerated documentation has been split into several files for ease of access and reading.</p> <ul> <li> <p> Anime Modules</p> <p>The documentation generated for pymoe.anime and its submodules.</p> <p> Anime</p> </li> <li> <p> Manga Modules</p> <p>The documentation generated for pymoe.manga and its submodules.</p> <p> Manga</p> </li> <li> <p> LN Modules</p> <p>The documentation generated for pymoe.ln and its submodules.</p> <p> LN</p> </li> </ul>"},{"location":"building/","title":"Building","text":"<p>This is a short document explaining the build pipeline I have setup for this project in case you want to build from source.</p>"},{"location":"building/#tools-used","title":"Tools Used","text":"<p>Required Tools</p> <p>The only required tool for building is Poetry. You can technically skip this requirement, but the project is setup to use Poetry's build pipeline so you're on your own for configuring another build pipeline.</p> <ul> <li>Poetry</li> <li>Task</li> <li>Black Code Formatter</li> <li>isort Code Formatter</li> </ul>"},{"location":"building/#building_1","title":"Building","text":""},{"location":"building/#using-poetry","title":"Using Poetry","text":"<p>Clone the repository into a folder, CD into that folder and then... <pre><code>poetry install --sync\npoetry build\ncd dist\npip install pymoe-2.2-py3-none-any.whl # Or whatever your whl ends up being named\n</code></pre></p>"},{"location":"building/#using-task","title":"Using Task","text":"<p>If you have Task installed on your machine, you can run a task to build the project. This method still requires Poetry as Task will run poetry commands to ensure a clean build environment.</p> <pre><code>task run make-build\n</code></pre> <p>This might take a bit to run as it will clean the environment, setup the cleaning environment, run Black and isort against the code, clean the environment, and finally build the sdist and wheel.</p> <p>There are a few other tasks you might be interested in:</p> <ul> <li>serve-docs will build and serve the documentation locally.</li> <li>run-pytest will setup a testing environment and run through the unit tests.</li> </ul> <p>You can get a full list of available tasks by running <code>task --list</code> in the directory you cloned. The unittests take around five minutes because there is a forced two second waiting period between each request to lessen the impact on the API providers.</p>"},{"location":"userguide/","title":"User Guide","text":"<p>The User Guide is split into three sections and covers details for each module as well as specifics on each service.</p> <ul> <li> <p> Anime</p> <p>The User Guide for pymoe.anime</p> <p> Anime</p> </li> <li> <p> Manga</p> <p>The documentation generated for pymoe.manga and its submodules.</p> <p> Manga</p> </li> <li> <p> LN</p> <p>The documentation generated for pymoe.ln and its submodules.</p> <p> LN</p> </li> </ul>"},{"location":"anime/anilist/","title":"Pymoe.Anime - Anilist","text":"<p>This is the documentation for the Anilist module of Pymoe.Anime.</p>"},{"location":"anime/anilist/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> character, show, season, episode, streaming, staff, studio <code>SEARCH</code> characters, shows, staff, studios, airingSchedule, dynamicRequest <p>Anilist does not separate staff and studios by manga and anime. Otherwise, Anilist is one of the easiest APIs to work with. It provides predictable results with easily inferred structures. It also supports most anything you could possibly need to build any kind of app from streaming links to episode details to airingSchedules.</p>"},{"location":"anime/anilist/#some-notes","title":"Some Notes","text":""},{"location":"anime/anilist/#streaming-airingschedule-and-dynamicrequest","title":"Streaming, airingSchedule and dynamicRequest","text":"<p>The only methods that really need notes are these three. The rest of the endpoints work exactly how you would expect them to. If you search for characters you're going to get back a list of characters matching your term. If you get a character, you get information back on that character. So on and so forth.</p> <p>Streaming on the other hand essentially returns the list of episodes for a series ID that appears under the WATCH header on their website. If you've never clicked on these, they actually take you to a site where you can stream the episode. So for Frieren: Beyond Journey's End this returns a list of links to Crunchyroll where you can watch the episodes. This endpoint can be useful for other reasons as well since it also returns episode numbers, release dates, and titles.</p> <p>AiringSchedule returns a list of episodes and the datetime on which they air. This will return all episodes for a given series so it is possible for the datetime to be negative to indicate it happened in the past. The datetime is passed by the timeUntilAiring attribute and it is simply a number of seconds to/since the airing time.</p> <p>DynamicRequest allows you to run your own GraphQL queries against the Anilist API. We also handle grabbing the data and will even return it as an API Aware iterator if there are multiple results. Keep in mind that this only accepts one argument: A dictionary containing the data required to be posted to the API. That is it needs to have both a 'query' key with the GraphQL Query and a 'variables' key with the needed variables.</p>"},{"location":"anime/anilist/#some-examples","title":"Some Examples","text":"<pre><code>import pymoe\n\n# Get streaming episodes for Frieren: Beyond Journey's End\npymoe.anime.get.anilist.streaming(154587)\n\n# Example Dynamic Request\nparameters = {\n    'query': \"\"\"\\\n        query ($query: String, $page: Int, $perPage: Int){\n            Page (page: $page, perPage: $perPage) {\n                pageInfo {\n                    currentPage\n                    hasNextPage\n                }\n                characters (search: $query) {\n                    id\n                }\n            }\n        }\n    \"\"\",\n    'variables': {\"query\": \"Frieren\", \"page\": 1, \"perPage\": 3}\n}\npymoe.anime.search.anilist.dynamicRequest(parameters)\n</code></pre>"},{"location":"anime/kitsu/","title":"Pymoe.Anime - Kitsu","text":"<p>This is the documentation for the Kitsu module of Pymoe.Anime.</p>"},{"location":"anime/kitsu/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> character, show, episode, staff, studio <code>SEARCH</code> characters, shows, staff, studios, season, streaming <p>End of Life</p> <p>Just a reminder that eventually the Search endpoints for Kitsu will be removed and I heavily suggest moving to MAL or Anilist. Get endpoints will remain here until they stop working though my understanding is they will not.</p>"},{"location":"anime/kitsu/#return-formatting","title":"Return Formatting","text":"<p>It's everywhere. It's pretty apparent they used one of those tools that automatically generates a swagger API based on data models and the data returned mirrors that. There's no standard return formatting. Your best bet is to test the functions and look at the return data structure. You can also use their apiary documentation to send test requests to get returns.</p>"},{"location":"anime/kitsu/#some-notes","title":"Some Notes","text":""},{"location":"anime/kitsu/#unsupported-endpoints","title":"Unsupported Endpoints","text":"<p>The only endpoints that actually work here are character(s), show(s), season, episode, and streaming. The others remain here because I make efforts to maintain parity between all the modules of a specific type.</p>"},{"location":"anime/kitsu/#some-examples","title":"Some Examples","text":"<pre><code># Apparently this is a character called Freezen\npymoe.anime.get.kitsu.character(85849)\n\n# This is the last episode of Frieren: Beyond Journey's End\npymoe.anime.get.kitsu.episode(353471)\n</code></pre>"},{"location":"anime/mal/","title":"Pymoe.Anime - MAL","text":"<p>This is the documentation for the MyAnimeList (MAL) module of Pymoe.Anime.</p>"},{"location":"anime/mal/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> character, show, episode, streaming, staff, studio <code>SEARCH</code> shows, staff, studios, season"},{"location":"anime/mal/#supported-interfaces","title":"Supported Interfaces","text":"<p>It's just show(s) and season. You can search shows, you can get shows, and you can grab a seasonal listing. That's it. </p>"},{"location":"anime/mal/#return-formatting","title":"Return Formatting","text":"<p>It returns without any special formatting. It's a very straightforward API. </p>"},{"location":"anime/mal/#some-examples","title":"Some Examples","text":"<pre><code>import pymoe\n\n# Get Frieren: Beyond Journey's End\npymoe.anime.get.mal.show(52991)\n\n# Get a seasonal list for the current season\npymoe.anime.search.mal.season()\n</code></pre>"},{"location":"anime/start/","title":"Pymoe.Anime","text":"<p>What Does Default Mean?</p> <p>Whenever the term default is used, it refers to the top level functions available at pymoe.type.operation.endpoint. So <code>pymoe.anime.get.show</code> or <code>pymoe.manga.search.series</code>.</p> <p>This is the user guide for Pymoe.Anime and its submodules. This page will go over the default methods available at pymoe.anime.get and pymoe.anime.search. Further information on the specifics of each module are in their own documents.</p> Module Documentation Location <code>DEFAULT</code> This Page <code>ANILIST</code> Documentation <code>KITSU</code> Documentation <code>MAL</code> Documentation"},{"location":"anime/start/#default-methods","title":"Default Methods","text":"<p>These default methods route through Anilist.</p>"},{"location":"anime/start/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> character, show, episode, staff, studio <code>SEARCH</code> characters, shows, staff, studios, season"},{"location":"anime/start/#get-methods","title":"GET Methods","text":"Endpoint Description Provider <code>CHARACTER</code> Get information on a character given an ID Anilist <code>SHOW</code> Get information on a show given an ID Anilist <code>EPISODE</code> Get information on a specific episode given an ID Anilist <code>STAFF</code> Get information on a given staff member given an ID Anilist <code>STUDIO</code> Get information on a given studio given an ID Anilist <p>An Example</p> <pre><code># Get info on Frieren: Beyond Journey's End\npymoe.anime.get.show(154587)\n\n# Get info on Frieren of Frieren: Beyond Journey's End\npymoe.anime.get.character(176754)\n</code></pre>"},{"location":"anime/start/#search-methods","title":"Search Methods","text":"Endpoint Description Provider <code>CHARACTERS</code> Search for characters by name Anilist <code>SHOWS</code> Search for shows by name Anilist <code>STAFF</code> Search for staffers by name Anilist <code>STUDIOS</code> Search for studios by name Anilist <code>SEASON</code> Get seasonal anime Anilist <p>An Example</p> <pre><code># Search for shows matching Toradora\npymoe.anime.search.shows(\"Toradora\")\n\n# Get the latest seasonal anime\npymoe.anime.search.season()\n\n# Get a list of anime from winter season in 2021\npymoe.anime.search.season(\n    theSeason = \"winter\",\n    year = 2021\n)\n</code></pre>"},{"location":"anime/start/#return-formatting","title":"Return Formatting","text":"<p>Since Anilist uses GraphQL the return formatting matches exactly to the GraphQL queries being ran. For example, take the following excerpt.</p> <pre><code>query ($id: Int){\n            Staff (id: $id){\n                name {\n                    full\n                }\n</code></pre> <p>This is an excerpt from the pymoe.anime.get.anilist.staff function. The return formatting of this function is going to be exactly as it appears in this query wrapped in a data key. If you want the full name of the staffer being requested from the returned results it would be: <pre><code>results['data']['Staff']['name']['full']\n</code></pre></p> <p>Search endpoints work the same way, but there's a catch. Since the search endpoints are generally always going to return multiple pages of results, you're most likely to get back an API Aware iterator than the data itself. With our API Aware iterators you do not need to worry about extracting the data and can simply directly access elements. In other words, if the above query had returned as an API Aware iterator instead of a single result you would be able to simply: <pre><code>results[0]['name']['full']\n</code></pre></p> <p>If a search endpoint only returns one page of results, we return that list of results directly so the previous code would still work.</p>"},{"location":"autogen/anime/","title":"Anime Classes","text":""},{"location":"autogen/anime/#pymoeanime","title":"pymoe.anime","text":""},{"location":"autogen/anime/#pymoe.anime.setMalClient","title":"<code>setMalClient(client_id)</code>","text":"<p>This is a helper function to set the MyAnimeList Client ID at both endpoints.</p> PARAMETER  DESCRIPTION <code>client_id</code> <p>Your Client ID</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymoe\\anime\\__init__.py</code> <pre><code>def setMalClient(client_id: str):\n    \"\"\"\n    This is a helper function to set the MyAnimeList Client ID at both endpoints.\n\n    :param client_id: Your Client ID\n    \"\"\"\n    mg.settings[\"header\"][\"X-MAL-CLIENT-ID\"] = client_id\n    ms.settings[\"header\"][\"X-MAL-CLIENT-ID\"] = client_id\n</code></pre>"},{"location":"autogen/anime/#pymoeanimeget","title":"pymoe.anime.get","text":""},{"location":"autogen/anime/#pymoe.anime.get.character","title":"<code>character(item_id)</code>","text":"<p>Return a Character from Anilist with the given ID</p> Source code in <code>pymoe\\anime\\get\\__init__.py</code> <pre><code>def character(item_id: int):\n    \"\"\"\n    Return a Character from Anilist with the given ID\n    \"\"\"\n    return anilist.character(item_id)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.episode","title":"<code>episode(item_id)</code>","text":"<p>Return an Episode from Anilist with the given ID</p> Source code in <code>pymoe\\anime\\get\\__init__.py</code> <pre><code>def episode(item_id: int):\n    \"\"\"\n    Return an Episode from Anilist with the given ID\n    \"\"\"\n    return anilist.episode(item_id)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.show","title":"<code>show(item_id)</code>","text":"<p>Return a Show from Anilist with the given ID</p> Source code in <code>pymoe\\anime\\get\\__init__.py</code> <pre><code>def show(item_id: int):\n    \"\"\"\n    Return a Show from Anilist with the given ID\n    \"\"\"\n    return anilist.show(item_id)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.staff","title":"<code>staff(item_id)</code>","text":"<p>Return a Staff member from Anilist with the given ID</p> Source code in <code>pymoe\\anime\\get\\__init__.py</code> <pre><code>def staff(item_id: int):\n    \"\"\"\n    Return a Staff member from Anilist with the given ID\n    \"\"\"\n    return anilist.staff(item_id)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.studio","title":"<code>studio(item_id)</code>","text":"<p>Return a Studio from Anilist with the given ID</p> Source code in <code>pymoe\\anime\\get\\__init__.py</code> <pre><code>def studio(item_id: int):\n    \"\"\"\n    Return a Studio from Anilist with the given ID\n    \"\"\"\n    return anilist.studio(item_id)\n</code></pre>"},{"location":"autogen/anime/#pymoeanimegetanilist","title":"pymoe.anime.get.anilist","text":""},{"location":"autogen/anime/#pymoe.anime.get.anilist.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json'}, 'apiurl': 'https://graphql.anilist.co'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/anime/#pymoe.anime.get.anilist.character","title":"<code>character(item_id)</code>","text":"<p>Get a character with a certain ID in the anilist API.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the character you want information on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def character(item_id: int):\n    \"\"\"\n    Get a character with a certain ID in the anilist API.\n\n    :param item_id: The ID of the character you want information on.\n    \"\"\"\n    query_string = \"\"\"\n        query ($id: Int){\n            Character (id: $id){\n                name{\n                    full\n                }\n                image {\n                    large\n                    medium\n                }\n                description\n                gender\n                age\n                siteUrl\n                media{\n                    nodes{\n                        id\n                        idMal\n                        title {\n                            romaji\n                            english\n                            native\n                        }\n                        coverImage {\n                            extraLarge\n                            large\n                            medium\n                            color\n                        }\n                        siteUrl\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"query\": query_string, \"variables\": {\"id\": item_id}},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.anilist.episode","title":"<code>episode(item_id)</code>","text":"<p>Unsupported on Anilist</p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def episode(item_id: int):\n    \"\"\"\n    Unsupported on Anilist\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.get.anilist.episode\", \"anilist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.anilist.season","title":"<code>season(theSeason=None, year=date.today().year, page=1, perPage=3)</code>","text":"<p>Get a list of seasonal anime given a season and year.</p> PARAMETER  DESCRIPTION <code>theSeason</code> <p>What Season? See pymoe.utils.helpers for a list of seasons. If not provided we will determine the season for you based on the current month.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>year</code> <p>What year do you want info on?</p> <p> TYPE: <code>int</code> DEFAULT: <code>year</code> </p> <code>page</code> <p>Which page of results do you want?</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def season(\n    theSeason: str = None, year: int = date.today().year, page: int = 1, perPage: int = 3\n):\n    \"\"\"\n    Get a list of seasonal anime given a season and year.\n\n    :param theSeason: What Season? See pymoe.utils.helpers for a list of seasons. If not provided we will determine the season for you based on the current month.\n    :param year: What year do you want info on?\n    :param page: Which page of results do you want?\n    :param perPage: How many results per page?\n    \"\"\"\n    myseason = theSeason if theSeason else whatSeason(date.today().month)\n\n    query_string = \"\"\"\n        query($season: MediaSeason, $seasonYear: Int, $page: Int, $perPage: Int){\n            Page (page: $page, perPage: $perPage) {\n                pageInfo {\n                    currentPage\n                    hasNextPage\n                }\n                media (season: $season, seasonYear: $seasonYear){\n                    id\n                    idMal\n                    title {\n                        romaji\n                        english\n                        native\n                    }\n                    description\n                    genres\n                    coverImage {\n                        extraLarge\n                        large\n                        medium\n                        color\n                    }\n                    isAdult\n                    nextAiringEpisode {\n                        timeUntilAiring\n                        airingAt\n                    }\n                    startDate {\n                        year\n                        month\n                        day\n                    }\n                    streamingEpisodes {\n                        title\n                        thumbnail\n                        url\n                        site\n                    }\n                    siteUrl\n                    externalLinks {\n                        url\n                        site\n                        language\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    jsonData = {\n        \"query\": query_string,\n        \"variables\": {\n            \"season\": myseason.upper(),\n            \"seasonYear\": year,\n            \"page\": page,\n            \"perPage\": perPage,\n        },\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=jsonData)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"media\"],\n                    jsonData,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"media\"]\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.anilist.show","title":"<code>show(item_id)</code>","text":"<p>Get a show with a certain ID in the anilist API.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the show you want information on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def show(item_id: int):\n    \"\"\"\n    Get a show with a certain ID in the anilist API.\n\n    :param item_id: The ID of the show you want information on.\n    \"\"\"\n    query_string = \"\"\"\n        query ($id: Int) {\n            Media (id: $id, type: ANIME) {\n                title {\n                    romaji\n                    english\n                    native\n                }\n                startDate {\n                    year\n                    month\n                    day\n                }\n                endDate {\n                    year\n                    month\n                    day\n                }\n                coverImage {\n                    extraLarge\n                    large\n                    medium\n                    color\n                }\n                bannerImage\n                format\n                status\n                episodes\n                season\n                seasonYear\n                description\n                averageScore\n                meanScore\n                genres\n                synonyms\n                isAdult\n                siteUrl\n                idMal\n                popularity\n                nextAiringEpisode {\n                    timeUntilAiring\n                    airingAt\n                }\n                streamingEpisodes {\n                    title\n                    thumbnail\n                    url\n                    site\n                }\n                externalLinks{\n                    url\n                    site\n                    language\n                }\n                characters {\n                    nodes {\n                        id\n                        name {\n                            first\n                            last\n                        }\n                        image {\n                            large\n                            medium\n                        }\n                        description\n                        gender\n                        age\n                        siteUrl\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"query\": query_string, \"variables\": {\"id\": item_id}},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.anilist.staff","title":"<code>staff(item_id)</code>","text":"<p>Get information on a specific staffer given their ID.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the staff member you want information on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def staff(item_id: int):\n    \"\"\"\n    Get information on a specific staffer given their ID.\n\n    :param item_id: The ID of the staff member you want information on.\n    \"\"\"\n    query_string = \"\"\"\n        query ($id: Int){\n            Staff (id: $id){\n                name {\n                    full\n                }\n                languageV2\n                image {\n                    large\n                    medium\n                }\n                description\n                primaryOccupations\n                gender\n                dateOfBirth {\n                    year\n                    month\n                    day\n                }\n                dateOfDeath {\n                    year\n                    month\n                    day\n                }\n                age\n                homeTown\n                yearsActive\n                siteUrl\n                staffMedia{\n                    nodes {\n                        id\n                        idMal\n                        title {\n                            romaji\n                            english\n                            native\n                        }\n                        coverImage {\n                            extraLarge\n                            large\n                            medium\n                            color\n                        }\n                        siteUrl\n                    }\n                }\n                characters{\n                    nodes {\n                        name {\n                            full\n                        }\n                        image {\n                            large\n                            medium\n                        }\n                        age\n                        siteUrl\n                        media {\n                            nodes {\n                                id\n                                idMal\n                                title {\n                                    romaji\n                                    english\n                                    native\n                                }\n                                coverImage {\n                                    extraLarge\n                                    large\n                                    medium\n                                    color\n                                }\n                                siteUrl\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"query\": query_string, \"variables\": {\"id\": item_id}},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.anilist.streaming","title":"<code>streaming(item_id, page=1, perPage=3)</code>","text":"<p>Given a show ID, return all streaming links for that show. Unlike Kitsu, this returns one streaming link per episode per service.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the show you want streaming links for</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def streaming(item_id: int, page: int = 1, perPage: int = 3):\n    \"\"\"\n    Given a show ID, return all streaming links for that show.\n    Unlike Kitsu, this returns one streaming link per episode per service.\n\n    :param item_id: The ID of the show you want streaming links for\n    \"\"\"\n    query_string = \"\"\"\n        query ($id: Int) {\n            Media(id: $id){\n                streamingEpisodes {\n                    title\n                    thumbnail\n                    url\n                    site\n                }\n            }\n        }\n    \"\"\"\n\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"query\": query_string, \"variables\": {\"id\": item_id}},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.anilist.studio","title":"<code>studio(item_id)</code>","text":"<p>Get a studio with a specific id.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the studio you want information on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\anilist.py</code> <pre><code>def studio(item_id: int):\n    \"\"\"\n    Get a studio with a specific id.\n\n    :param item_id: The ID of the studio you want information on.\n    \"\"\"\n    query_string = \"\"\"\n        query ($id: Int) {\n            Studio (id: $id) {\n                name\n                siteUrl\n                media {\n                    nodes {\n                        id\n                        idMal\n                        title {\n                            romaji\n                            english\n                            native\n                        }\n                        coverImage {\n                            extraLarge\n                            large\n                            medium\n                            color\n                        }\n                        siteUrl\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"query\": query_string, \"variables\": {\"id\": item_id}},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoeanimegetkitsu","title":"pymoe.anime.get.kitsu","text":""},{"location":"autogen/anime/#pymoe.anime.get.kitsu.settings","title":"<code>settings = {'header': {'Content-Type': 'application/vnd.api+json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/vnd.api+json'}, 'apiurl': 'https://kitsu.io/api/edge'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/anime/#pymoe.anime.get.kitsu.character","title":"<code>character(item_id)</code>","text":"<p>Get a character with the specific ID from the kitsu api.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID of the character you want info on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\kitsu.py</code> <pre><code>def character(item_id: int):\n    \"\"\"\n    Get a character with the specific ID from the kitsu api.\n\n    :param item_id: ID of the character you want info on.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/characters/{}\".format(item_id), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.kitsu.episode","title":"<code>episode(item_id)</code>","text":"<p>Get an episode with the specific ID from the kitsu api.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID of the episode you want info on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\kitsu.py</code> <pre><code>def episode(item_id: int):\n    \"\"\"\n    Get an episode with the specific ID from the kitsu api.\n\n    :param item_id: ID of the episode you want info on.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/episodes/{}\".format(item_id), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.kitsu.show","title":"<code>show(item_id)</code>","text":"<p>Get a show with the specific ID from the kitsu api.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID of the show you want info on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\kitsu.py</code> <pre><code>def show(item_id: int):\n    \"\"\"\n    Get a show with the specific ID from the kitsu api.\n\n    :param item_id: ID of the show you want info on.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/anime/{}\".format(item_id), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.kitsu.staff","title":"<code>staff(item_id)</code>","text":"<p>Get a staffer with the specific ID from the kitsu api.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID of the staffer you want info on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\kitsu.py</code> <pre><code>def staff(item_id: int):\n    \"\"\"\n    Get a staffer with the specific ID from the kitsu api.\n\n    :param item_id: ID of the staffer you want info on.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/anime-staff/{}/person\".format(item_id),\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.kitsu.studio","title":"<code>studio(item_id)</code>","text":"<p>Get a studio with the specific ID from the kitsu api.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID of the studio you want info on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\kitsu.py</code> <pre><code>def studio(item_id: int):\n    \"\"\"\n    Get a studio with the specific ID from the kitsu api.\n\n    :param item_id: ID of the studio you want info on.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/anime-productions/{}/producer\".format(item_id),\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoeanimegetmal","title":"pymoe.anime.get.mal","text":""},{"location":"autogen/anime/#pymoe.anime.get.mal.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json', 'X-MAL-CLIENT-ID': None}, 'apiurl': 'https://api.myanimelist.net/v2/', 'default_fields': 'id,title,main_picture,alternative_titles,start_date,end_date,synopsis,mean,rank,nsfw,genres,media_type,status,num_episodes,start_season,broadcast,source,rating,studios,related_anime,related_manga'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/anime/#pymoe.anime.get.mal.character","title":"<code>character(item_id)</code>","text":"<p>No endpoint exists for this at this time Method not supported</p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def character(item_id: int):\n    \"\"\"\n    No endpoint exists for this at this time\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.get.mal.character\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.mal.episode","title":"<code>episode(item_id)</code>","text":"<p>No endpoint exists for this at this time Method not supported</p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def episode(item_id: int):\n    \"\"\"\n    No endpoint exists for this at this time\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.get.mal.episode\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.mal.keyAssert","title":"<code>keyAssert()</code>","text":"<p>This is just an assert. It cancels the request if the API Key is not present.</p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def keyAssert():\n    \"\"\"\n    This is just an assert. It cancels the request if the API Key is not present.\n    \"\"\"\n    if (\n        not settings[\"header\"][\"X-MAL-CLIENT-ID\"]\n        or type(settings[\"header\"][\"X-MAL-CLIENT-ID\"]) != str\n    ):\n        raise ValueError(\"pymoe.anime.get.mal.keyAssert: API Key should be a string.\")\n    else:\n        pass\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.mal.show","title":"<code>show(item_id, fields=None)</code>","text":"<p>Get a show with the specific ID from the myanimelist api.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID of the show you want info on.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def show(item_id: int, fields: str = None):\n    \"\"\"\n    Get a show with the specific ID from the myanimelist api.\n\n    :param item_id: ID of the show you want info on.\n    \"\"\"\n    keyAssert()\n\n    r = requests.get(\n        settings[\"apiurl\"] + \"anime/{}\".format(item_id),\n        params={\"fields\": fields or settings[\"default_fields\"], \"nsfw\": \"true\"},\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    return ujson.loads(r.text)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.mal.staff","title":"<code>staff(item_id)</code>","text":"<p>No endpoint exists for this at this time Method not supported</p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def staff(item_id: int):\n    \"\"\"\n    No endpoint exists for this at this time\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.get.mal.staff\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.mal.streaming","title":"<code>streaming(item_id)</code>","text":"<p>No endpoint exists for this at this time Method not supported</p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def streaming(item_id: int):\n    \"\"\"\n    No endpoint exists for this at this time\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.get.mal.streaming\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.get.mal.studio","title":"<code>studio(item_id)</code>","text":"<p>No endpoint exists for this at this time Method not supported</p> Source code in <code>pymoe\\anime\\get\\mal.py</code> <pre><code>def studio(item_id: int):\n    \"\"\"\n    No endpoint exists for this at this time\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.get.mal.studio\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoeanimesearch","title":"pymoe.anime.search","text":""},{"location":"autogen/anime/#pymoe.anime.search.characters","title":"<code>characters(term)</code>","text":"<p>Search for characters that match term on anilist</p> Source code in <code>pymoe\\anime\\search\\__init__.py</code> <pre><code>def characters(term: str):\n    \"\"\"\n    Search for characters that match term on anilist\n    \"\"\"\n    return anilist.characters(term)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.season","title":"<code>season(season=None, seasonYear=date.today().year)</code>","text":"<p>Given a season and seasonYear, return the list of seasonal anime from Anilist.</p> Source code in <code>pymoe\\anime\\search\\__init__.py</code> <pre><code>def season(season: str = None, seasonYear: int = date.today().year):\n    \"\"\"\n    Given a season and seasonYear, return the list of seasonal anime from Anilist.\n    \"\"\"\n    return asg(season, seasonYear)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.shows","title":"<code>shows(term)</code>","text":"<p>Search for characters that match term on anilist</p> Source code in <code>pymoe\\anime\\search\\__init__.py</code> <pre><code>def shows(term: str):\n    \"\"\"\n    Search for characters that match term on anilist\n    \"\"\"\n    return anilist.shows(term)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.staff","title":"<code>staff(term)</code>","text":"<p>Search for characters that match term on anilist</p> Source code in <code>pymoe\\anime\\search\\__init__.py</code> <pre><code>def staff(term: str):\n    \"\"\"\n    Search for characters that match term on anilist\n    \"\"\"\n    return anilist.staff(term)\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.studios","title":"<code>studios(term)</code>","text":"<p>Search for characters that match term on anilist</p> Source code in <code>pymoe\\anime\\search\\__init__.py</code> <pre><code>def studios(term: str):\n    \"\"\"\n    Search for characters that match term on anilist\n    \"\"\"\n    return anilist.studios(term)\n</code></pre>"},{"location":"autogen/anime/#pymoeanimesearchanilist","title":"pymoe.anime.search.anilist","text":""},{"location":"autogen/anime/#pymoe.anime.search.anilist.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json'}, 'apiurl': 'https://graphql.anilist.co'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/anime/#pymoe.anime.search.anilist.airingSchedule","title":"<code>airingSchedule(item_id)</code>","text":"<p>Given an anime id, return the airing schedule. This returns a full airing schedule, including already aired episodes. If an episode has already aired timeUntilAiring will be &lt;= 0. timeUntilAiring is just seconds.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the show you want a schedule for</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\search\\anilist.py</code> <pre><code>def airingSchedule(item_id: int):\n    \"\"\"\n    Given an anime id, return the airing schedule.\n    This returns a full airing schedule, including already aired episodes.\n    If an episode has already aired timeUntilAiring will be &lt;= 0.\n    timeUntilAiring is just seconds.\n\n    :param item_id: The ID of the show you want a schedule for\n    \"\"\"\n    query_string = \"\"\"\\\n        query( $id: Int, $page: Int, $perPage: Int ) {\n            Page ( page: $page, perPage: $perPage ) {\n                pageInfo {\n                    currentPage\n                    hasNextPage\n                }\n                airingSchedules ( mediaId: $id ) {\n                    id\n                    episode\n                    timeUntilAiring\n                }\n            }\n        }\n    \"\"\"\n\n    json_params = {\n        \"query\": query_string,\n        \"variables\": {\"id\": item_id, \"page\": 1, \"perPage\": 3},\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"airingSchedules\"],\n                    json_params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"airingSchedules\"]\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.anilist.characters","title":"<code>characters(term, page=1, perPage=3)</code>","text":"<p>Search for characters that match the term in the API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> <code>page</code> <p>Which page of the results?</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>pymoe\\anime\\search\\anilist.py</code> <pre><code>def characters(term: str, page: int = 1, perPage: int = 3):\n    \"\"\"\n    Search for characters that match the term in the API.\n\n    :param term: Search Term\n    :param page: Which page of the results?\n    :param perPage: How many results per page?\n    \"\"\"\n    query_string = \"\"\"\\\n        query ($query: String, $page: Int, $perPage: Int){\n            Page (page: $page, perPage: $perPage) {\n                pageInfo {\n                    currentPage\n                    hasNextPage\n                }\n                characters (search: $query) {\n                    id\n                    name{\n                        first\n                        last\n                    }\n                    image{\n                        large\n                    }\n                    description\n                    gender\n                    age\n                    siteUrl\n                    media {\n                        nodes {\n                            id\n                            idMal\n                            title {\n                                romaji\n                                english\n                                native\n                            }\n                            coverImage {\n                                extraLarge\n                                large\n                                medium\n                                color\n                            }\n                            siteUrl\n                        }\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    json_params = {\n        \"query\": query_string,\n        \"variables\": {\"query\": term, \"page\": page, \"perPage\": perPage},\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"characters\"],\n                    json_params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"characters\"]\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.anilist.dynamicRequest","title":"<code>dynamicRequest(params)</code>","text":"<p>This allows you to run a query you wrote yourself against the anilist API. You have to pass both a properly formatted query and the dictionary of parameters needed. If your request returns multiple results, you will get back a wrapper.</p> PARAMETER  DESCRIPTION <code>params</code> <p>Dictionary of parameters needed for the request. Note this needs to include the GraphQL query.</p> <p> TYPE: <code>Dict</code> </p> Source code in <code>pymoe\\anime\\search\\anilist.py</code> <pre><code>def dynamicRequest(params: Dict):\n    \"\"\"\n    This allows you to run a query you wrote yourself against the anilist API.\n    You have to pass both a properly formatted query and the dictionary of parameters needed.\n    If your request returns multiple results, you will get back a wrapper.\n\n    :param params: Dictionary of parameters needed for the request. Note this needs to include the GraphQL query.\n    \"\"\"\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"airingSchedules\"],\n                    params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"airingSchedules\"]\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.anilist.shows","title":"<code>shows(term, page=1, perPage=3)</code>","text":"<p>Search for shows(anime) that match the term in the API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> <code>page</code> <p>Which page of the results?</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>pymoe\\anime\\search\\anilist.py</code> <pre><code>def shows(term: str, page: int = 1, perPage: int = 3):\n    \"\"\"\n    Search for shows(anime) that match the term in the API.\n\n    :param term: Search Term\n    :param page: Which page of the results?\n    :param perPage: How many results per page?\n    \"\"\"\n    query_string = \"\"\"\\\n        query ($query: String, $page: Int, $perPage: Int){\n            Page (page: $page, perPage: $perPage){\n                pageInfo {\n                    currentPage\n                    hasNextPage\n                }\n                media (search: $query, type: ANIME) {\n                    id\n                    idMal\n                    title {\n                        romaji\n                        english\n                        native\n                    }\n                    coverImage {\n                        extraLarge\n                        large\n                        medium\n                        color\n                    }\n                    averageScore\n                    popularity\n                    episodes\n                    season\n                    hashtag\n                    isAdult\n                    siteUrl\n                    characters {\n                        nodes {\n                            id\n                            name {\n                                first\n                                last\n                            }\n                            image {\n                                large\n                                medium\n                            }\n                            description\n                            gender\n                            age\n                            siteUrl\n                        }\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    json_params = {\n        \"query\": query_string,\n        \"variables\": {\"query\": term, \"page\": page, \"perPage\": perPage},\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"media\"],\n                    json_params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"media\"]\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.anilist.staff","title":"<code>staff(term, page=1, perPage=3)</code>","text":"<p>Search for staffers that match the term in the API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> <code>page</code> <p>Which page of the results?</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>pymoe\\anime\\search\\anilist.py</code> <pre><code>def staff(term: str, page: int = 1, perPage: int = 3):\n    \"\"\"\n    Search for staffers that match the term in the API.\n\n    :param term: Search Term\n    :param page: Which page of the results?\n    :param perPage: How many results per page?\n    \"\"\"\n    query_string = \"\"\"\\\n        query($query: String, $page: Int, $perPage: Int){\n            Page(page: $page, perPage: $perPage){\n                pageInfo{\n                    currentPage\n                    hasNextPage\n                }\n                staff (search: $query){\n                    id\n                    name {\n                        first\n                        last\n                    }\n                    languageV2\n                    image {\n                        large\n                        medium\n                    }\n                    description\n                    primaryOccupations\n                    gender\n                    dateOfBirth {\n                        year\n                        month\n                        day\n                    }\n                    dateOfDeath {\n                        year\n                        month\n                        day\n                    }\n                    age\n                    homeTown\n                    yearsActive\n                    siteUrl\n                    staffMedia {\n                        nodes {\n                            id\n                            idMal\n                            title {\n                                romaji\n                                english\n                                native\n                            }\n                            coverImage {\n                                extraLarge\n                                large\n                                medium\n                                color\n                            }\n                            siteUrl\n                        }\n                    }\n                    characters {\n                        nodes {\n                            name {\n                                first\n                                last\n                            }\n                            image {\n                                large\n                                medium\n                            }\n                            age\n                            siteUrl\n                            media {\n                                nodes {\n                                    id\n                                    idMal\n                                    title {\n                                        romaji\n                                        english\n                                        native\n                                    }\n                                    coverImage {\n                                        extraLarge\n                                        large\n                                        medium\n                                        color\n                                    }\n                                    siteUrl\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    json_params = {\n        \"query\": query_string,\n        \"variables\": {\"query\": term, \"page\": page, \"perPage\": perPage},\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"staff\"],\n                    json_params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"staff\"]\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.anilist.studios","title":"<code>studios(term, page=1, perPage=3)</code>","text":"<p>Search for studios that match the term in the API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> <code>page</code> <p>Which page of the results?</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>pymoe\\anime\\search\\anilist.py</code> <pre><code>def studios(term: str, page: int = 1, perPage: int = 3):\n    \"\"\"\n    Search for studios that match the term in the API.\n\n    :param term: Search Term\n    :param page: Which page of the results?\n    :param perPage: How many results per page?\n    \"\"\"\n    query_string = \"\"\"\\\n        query($query: String, $page: Int, $perPage: Int){\n            Page(page: $page, perPage: $perPage){\n                pageInfo{\n                    currentPage\n                    hasNextPage\n                }\n                studios(search: $query){\n                    id\n                    name\n                    siteUrl\n                    media {\n                        nodes {\n                            id\n                            idMal\n                            title {\n                                romaji\n                                english\n                                native\n                            }\n                            coverImage {\n                                extraLarge\n                                large\n                                medium\n                                color\n                            }\n                            siteUrl\n                        }\n                    }\n                }\n            }\n        }\n    \"\"\"\n\n    json_params = {\n        \"query\": query_string,\n        \"variables\": {\"query\": term, \"page\": page, \"perPage\": perPage},\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"studios\"],\n                    json_params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"studios\"]\n</code></pre>"},{"location":"autogen/anime/#pymoeanimesearchkitsu","title":"pymoe.anime.search.kitsu","text":""},{"location":"autogen/anime/#pymoe.anime.search.kitsu.settings","title":"<code>settings = {'header': {'Content-Type': 'application/vnd.api+json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/vnd.api+json'}, 'apiurl': 'https://kitsu.io/api/edge'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/anime/#pymoe.anime.search.kitsu.characters","title":"<code>characters(term)</code>","text":"<p>Search for characters that match the term in the Kitsu API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymoe\\anime\\search\\kitsu.py</code> <pre><code>def characters(term: str):\n    \"\"\"\n    Search for characters that match the term in the Kitsu API.\n\n    :param term: Search Term\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/characters\",\n        params={\"filter[name]\": term},\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"meta\"][\"count\"]:\n            return kitsuWrapper(\n                jsd[\"data\"],\n                jsd[\"links\"][\"next\"] if \"next\" in jsd[\"links\"] else None,\n                settings[\"header\"],\n            )\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.kitsu.season","title":"<code>season(season=None, seasonYear=date.today().year)</code>","text":"<p>Given a season and a year, return a list of shows airing in that season and year. This can also pull historical and future data. (Though not too far in the future)</p> PARAMETER  DESCRIPTION <code>season</code> <p>Which Season? See pymoe.helpers for a list of seasons.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>seasonYear</code> <p>What year?</p> <p> TYPE: <code>int</code> DEFAULT: <code>year</code> </p> Source code in <code>pymoe\\anime\\search\\kitsu.py</code> <pre><code>def season(season: str = None, seasonYear: int = date.today().year):\n    \"\"\"\n    Given a season and a year, return a list of shows airing in that season and year.\n    This can also pull historical and future data. (Though not too far in the future)\n\n    :param season: Which Season? See pymoe.helpers for a list of seasons.\n    :param seasonYear: What year?\n    \"\"\"\n    myseason = season if season else whatSeason(date.today().month)\n\n    r = requests.get(\n        settings[\"apiurl\"] + \"/anime\",\n        params={\"filter[season]\": myseason, \"filter[seasonYear]\": seasonYear},\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"meta\"][\"count\"]:\n            return kitsuWrapper(\n                jsd[\"data\"],\n                jsd[\"links\"][\"next\"] if \"next\" in jsd[\"links\"] else None,\n                settings[\"header\"],\n            )\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.kitsu.shows","title":"<code>shows(term)</code>","text":"<p>Search for shows that match the term in the Kitsu API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymoe\\anime\\search\\kitsu.py</code> <pre><code>def shows(term: str):\n    \"\"\"\n    Search for shows that match the term in the Kitsu API.\n\n    :param term: Search Term\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/anime\",\n        params={\"filter[text]\": term},\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"meta\"][\"count\"]:\n            return kitsuWrapper(\n                jsd[\"data\"],\n                jsd[\"links\"][\"next\"] if \"next\" in jsd[\"links\"] else None,\n                settings[\"header\"],\n            )\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.kitsu.staff","title":"<code>staff(term)</code>","text":"<p>Kitsu doesn't support text filtering on the anime-staff endpoint. Method not supported.</p> Source code in <code>pymoe\\anime\\search\\kitsu.py</code> <pre><code>def staff(term: str):\n    \"\"\"\n    Kitsu doesn't support text filtering on the anime-staff endpoint.\n    Method not supported.\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.search.kitsu.staff\", \"kitsu\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.kitsu.streaming","title":"<code>streaming(item_id)</code>","text":"<p>Given a media ID, return all streaming links related to that media. Unlike anilist, this returns one link per streaming service.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>ID to get streaming links for</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\anime\\search\\kitsu.py</code> <pre><code>def streaming(item_id: int):\n    \"\"\"\n    Given a media ID, return all streaming links related to that media.\n    Unlike anilist, this returns one link per streaming service.\n\n    :param item_id: ID to get streaming links for\n    \"\"\"\n    data = show(item_id)\n\n    r = requests.get(\n        data[\"data\"][\"relationships\"][\"streamingLinks\"][\"links\"][\"related\"],\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"meta\"][\"count\"]:\n            return kitsuWrapper(\n                jsd[\"data\"],\n                jsd[\"links\"][\"next\"] if \"next\" in jsd[\"links\"] else None,\n                settings[\"header\"],\n            )\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.kitsu.studios","title":"<code>studios(term)</code>","text":"<p>Kitsu doesn't support text filtering on the anime-producers endpoint. Method not supported.</p> Source code in <code>pymoe\\anime\\search\\kitsu.py</code> <pre><code>def studios(term: str):\n    \"\"\"\n    Kitsu doesn't support text filtering on the anime-producers endpoint.\n    Method not supported.\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.search.kitsu.studios\", \"kitsu\")\n</code></pre>"},{"location":"autogen/anime/#pymoeanimesearchmal","title":"pymoe.anime.search.mal","text":""},{"location":"autogen/anime/#pymoe.anime.search.mal.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json', 'X-MAL-CLIENT-ID': None}, 'apiurl': 'https://api.myanimelist.net/v2/', 'default_fields': 'id,title,main_picture,alternative_titles,start_date,end_date,synopsis,mean,rank,nsfw,genres,media_type,status,num_episodes,start_season,broadcast,source,rating,studios,related_anime,related_manga'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/anime/#pymoe.anime.search.mal.characters","title":"<code>characters(term)</code>","text":"<p>No endpoint exists for this at this time. Method not supported</p> Source code in <code>pymoe\\anime\\search\\mal.py</code> <pre><code>def characters(term: str):\n    \"\"\"\n    No endpoint exists for this at this time.\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.search.mal.characters\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.mal.keyAssert","title":"<code>keyAssert()</code>","text":"<p>This is just an assert. It cancels the request if the API Key is not present.</p> Source code in <code>pymoe\\anime\\search\\mal.py</code> <pre><code>def keyAssert():\n    \"\"\"\n    This is just an assert. It cancels the request if the API Key is not present.\n    \"\"\"\n    if (\n        not settings[\"header\"][\"X-MAL-CLIENT-ID\"]\n        or type(settings[\"header\"][\"X-MAL-CLIENT-ID\"]) != str\n    ):\n        raise ValueError(\"pymoe.anime.search.mal.keyAssert: API Key should be a string.\")\n    else:\n        pass\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.mal.season","title":"<code>season(season=None, seasonYear=date.today().year, limit=10, offset=0, nsfw=False)</code>","text":"<p>Search for shows from a given season in a given year.</p> PARAMETER  DESCRIPTION <code>season</code> <p>Which season? See pymoe.helpers for a list.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>seasonYear</code> <p>Which year?</p> <p> TYPE: <code>int</code> DEFAULT: <code>year</code> </p> <code>limit</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>offset</code> <p>Which result do we start at?</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>nsfw</code> <p>Return adult results?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pymoe\\anime\\search\\mal.py</code> <pre><code>def season(\n    season: str = None,\n    seasonYear: int = date.today().year,\n    limit: int = 10,\n    offset: int = 0,\n    nsfw: bool = False,\n):\n    \"\"\"\n    Search for shows from a given season in a given year.\n\n    :param season: Which season? See pymoe.helpers for a list.\n    :param seasonYear: Which year?\n    :param limit: How many results per page?\n    :param offset: Which result do we start at?\n    :param nsfw: Return adult results?\n    \"\"\"\n    keyAssert()\n\n    myseason = season or whatSeason(date.today().month)\n\n    r = requests.get(\n        settings[\"apiurl\"] + \"anime/season/{}/{}\".format(seasonYear, myseason),\n        params={\n            \"sort\": \"anime_score\",\n            \"limit\": limit,\n            \"offset\": offset,\n            \"fields\": \"id,title,main_picture,alternative_titles,start_date,broadcast\",\n            \"nsfw\": \"false\" if not nsfw else \"true\",\n        },\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n\n    rdict = [item[\"node\"] for item in jsd[\"data\"]]\n    r_url = jsd[\"paging\"][\"next\"] if \"next\" in jsd[\"paging\"] else None\n\n    return malWrapper(rdict, r_url, settings[\"header\"])\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.mal.shows","title":"<code>shows(term, fields=None, limit=10, offset=0, nsfw=False)</code>","text":"<p>Search for shows that match the given search term.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> <code>fields</code> <p>a comma separated list of fields to request from the API</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>offset</code> <p>Which result should we start at?</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>nsfw</code> <p>Return adult results?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pymoe\\anime\\search\\mal.py</code> <pre><code>def shows(\n    term: str,\n    fields: str | None = None,\n    limit: int = 10,\n    offset: int = 0,\n    nsfw: bool = False,\n):\n    \"\"\"\n    Search for shows that match the given search term.\n\n    :param term: Search Term\n    :param fields: a comma separated list of fields to request from the API\n    :param limit: How many results per page?\n    :param offset: Which result should we start at?\n    :param nsfw: Return adult results?\n    \"\"\"\n    keyAssert()\n\n    r = requests.get(\n        settings[\"apiurl\"] + \"anime\",\n        params={\n            \"q\": term,\n            \"fields\": settings[\"default_fields\"] or fields,\n            \"limit\": limit,\n            \"offset\": offset,\n            \"nsfw\": \"false\" if not nsfw else \"true\",\n        },\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n\n    rdict = [item[\"node\"] for item in jsd[\"data\"]]\n    r_url = jsd[\"paging\"][\"next\"] if \"next\" in jsd[\"paging\"] else None\n\n    return malWrapper(rdict, r_url, settings[\"header\"])\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.mal.staff","title":"<code>staff(term)</code>","text":"<p>No endpoint exists for this at this time. Method not supported</p> Source code in <code>pymoe\\anime\\search\\mal.py</code> <pre><code>def staff(term: str):\n    \"\"\"\n    No endpoint exists for this at this time.\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.search.mal.staff\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/anime/#pymoe.anime.search.mal.studios","title":"<code>studios(term)</code>","text":"<p>No endpoint exists for this at this time. Method not supported</p> Source code in <code>pymoe\\anime\\search\\mal.py</code> <pre><code>def studios(term: str):\n    \"\"\"\n    No endpoint exists for this at this time.\n    Method not supported\n    \"\"\"\n    raise methodNotSupported(\"pymoe.anime.search.mal.studios\", \"myanimelist\")\n</code></pre>"},{"location":"autogen/ln/","title":"LN Classes","text":""},{"location":"autogen/ln/#pymoelnget","title":"pymoe.ln.get","text":""},{"location":"autogen/ln/#pymoe.ln.get.artist","title":"<code>artist(item_id)</code>","text":"<p>Default get artist method from WLNUpdates</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def artist(item_id: int):\n    \"\"\"\n    Default get artist method from WLNUpdates\n    \"\"\"\n    return wlnupdates.artist(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.author","title":"<code>author(item_id)</code>","text":"<p>Default get author method from WLNUpdates</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def author(item_id: int):\n    \"\"\"\n    Default get author method from WLNUpdates\n    \"\"\"\n    return wlnupdates.author(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.genre","title":"<code>genre(item_id)</code>","text":"<p>Default get genre method from WLNUpdates. NOTICE: This will return all items with that genre.</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def genre(item_id: int):\n    \"\"\"\n    Default get genre method from WLNUpdates.\n    NOTICE: This will return all items with that genre.\n    \"\"\"\n    return wlnupdates.genre(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.group","title":"<code>group(item_id)</code>","text":"<p>Default get group method from WLNUpdates</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def group(item_id: int):\n    \"\"\"\n    Default get group method from WLNUpdates\n    \"\"\"\n    return wlnupdates.group(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.publisher","title":"<code>publisher(item_id)</code>","text":"<p>Default get publisher method from WLNUpdates</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def publisher(item_id: int):\n    \"\"\"\n    Default get publisher method from WLNUpdates\n    \"\"\"\n    return wlnupdates.publisher(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.series","title":"<code>series(item_id)</code>","text":"<p>Default get series method from WLNUpdates</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def series(item_id: int):\n    \"\"\"\n    Default get series method from WLNUpdates\n    \"\"\"\n    return wlnupdates.series(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.tag","title":"<code>tag(item_id)</code>","text":"<p>Default get tag method from WLNUpdates. NOTICE: This will return all items with that tag.</p> Source code in <code>pymoe\\ln\\get\\__init__.py</code> <pre><code>def tag(item_id: int):\n    \"\"\"\n    Default get tag method from WLNUpdates.\n    NOTICE: This will return all items with that tag.\n    \"\"\"\n    return wlnupdates.tag(item_id)\n</code></pre>"},{"location":"autogen/ln/#pymoelngetbakatsuki","title":"pymoe.ln.get.bakatsuki","text":""},{"location":"autogen/ln/#pymoe.ln.get.bakatsuki.settings","title":"<code>settings = {'apiurl': 'https://www.baka-tsuki.org/project/api.php', 'header': {'User-Agent': 'Pymoe (github.com/ccubed/Pymoe)'}, 'active': 56132, 'compiledRegex': {'chapter': re.compile('volume|chapter', re.I), 'separate': re.compile('(volume|chapter) (?P&lt;chapter&gt;[0-9]{1,2})', re.I)}}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/ln/#pymoe.ln.get.bakatsuki.active","title":"<code>active()</code>","text":"<p>Get a list of active projects.</p> RETURNS DESCRIPTION <p>A list of tuples containing a title and pageid in that order.</p> Source code in <code>pymoe\\ln\\get\\bakatsuki.py</code> <pre><code>def active():\n    \"\"\"\n    Get a list of active projects.\n\n    :return list: A list of tuples containing a title and pageid in that order.\n    \"\"\"\n    projects = []\n\n    r = requests.get(\n        settings[\"apiurl\"],\n        params={\n            \"action\": \"query\",\n            \"list\": \"categorymembers\",\n            \"cmpageid\": settings[\"active\"],\n            \"cmtype\": \"page\",\n            \"cmlimit\": \"500\",\n            \"format\": \"json\",\n        },\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code == 200:\n        jsd = ujson.loads(r.text)\n        projects.append(\n            [(x[\"title\"], x[\"pageid\"]) for x in jsd[\"query\"][\"categorymembers\"]]\n        )\n\n        if \"query-continue\" in jsd:\n            while True:\n                r = requests.get(\n                    settings[\"apiurl\"],\n                    params={\n                        \"action\": \"query\",\n                        \"list\": \"categorymembers\",\n                        \"cmpageid\": settings[\"active\"],\n                        \"cmtype\": \"page\",\n                        \"cmlimit\": \"500\",\n                        \"cmcontinue\": jsd[\"query-continue\"][\"categorymembers\"][\n                            \"cmcontinue\"\n                        ],\n                        \"format\": \"json\",\n                    },\n                    headers=settings[\"header\"],\n                )\n\n                if r.status_code == 200:\n\n                    jsd = ujson.loads(r.text)\n                    projects.append(\n                        [\n                            (x[\"title\"], x[\"pageid\"])\n                            for x in jsd[\"query\"][\"categorymembers\"]\n                        ]\n                    )\n\n                    if \"query-continue\" not in jsd:\n                        break\n\n                else:\n                    break\n\n    return projects[0]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.bakatsuki.chapters","title":"<code>chapters(title)</code>","text":"<p>Get a list of chapters for a visual novel. Keep in mind, this can be slow. I've certainly tried to make it as fast as possible, but it's still pulling text out of a webpage.</p> PARAMETER  DESCRIPTION <code>title</code> <p>The title of the novel you want chapters from</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>An OrderedDict which contains the chapters found for the visual novel supplied</p> Source code in <code>pymoe\\ln\\get\\bakatsuki.py</code> <pre><code>def chapters(title: str):\n    \"\"\"\n    Get a list of chapters for a visual novel. Keep in mind, this can be slow. I've certainly tried to make it as fast as possible, but it's still pulling text out of a webpage.\n\n    :param str title: The title of the novel you want chapters from\n    :return OrderedDict: An OrderedDict which contains the chapters found for the visual novel supplied\n    \"\"\"\n    r = requests.get(\n        \"https://www.baka-tsuki.org/project/index.php?title={}\".format(\n            title.replace(\" \", \"_\")\n        ),\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n    else:\n        parsed = soup(r.text, \"html.parser\")\n        dd = parsed.find_all(\"a\")\n\n        volumes = []\n        for link in dd:\n            if \"class\" in link.attrs:\n                if \"image\" in link.get(\"class\"):\n                    continue\n\n            if \"href\" in link.attrs:\n                if re.search(\n                    settings[\"compiledRegex\"][\"chapter\"], link.get(\"href\")\n                ) is not None and not link.get(\"href\").startswith(\"#\"):\n                    volumes.append(link)\n\n        seplist = OrderedDict()\n        for item in volumes:\n            if \"title\" in item.attrs:\n                result = re.search(\n                    settings[\"compiledRegex\"][\"separate\"], item.get(\"title\").lower()\n                )\n            else:\n                result = re.search(\n                    settings[\"compiledRegex\"][\"separate\"], item.text.lower()\n                )\n\n            if result and result.groups():\n                if result.group(\"chapter\").lstrip(\"0\") in seplist:\n                    seplist[result.group(\"chapter\").lstrip(\"0\")].append(\n                        [\n                            item.get(\"href\"),\n                            item.get(\"title\") if \"title\" in item.attrs else item.text,\n                        ]\n                    )\n                else:\n                    seplist[result.group(\"chapter\").lstrip(\"0\")] = [\n                        [\n                            item.get(\"href\"),\n                            item.get(\"title\") if \"title\" in item.attrs else item.text,\n                        ]\n                    ]\n\n        return seplist\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.bakatsuki.cover","title":"<code>cover(pageid)</code>","text":"<p>Get a cover image given a page id.</p> PARAMETER  DESCRIPTION <code>pageid</code> <p>The pageid for the light novel you want a cover image for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>the image url or None</p> Source code in <code>pymoe\\ln\\get\\bakatsuki.py</code> <pre><code>def cover(pageid: str):\n    \"\"\"\n    Get a cover image given a page id.\n\n    :param str pageid: The pageid for the light novel you want a cover image for\n    :return str: the image url or None\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"],\n        params={\n            \"action\": \"query\",\n            \"prop\": \"pageimages\",\n            \"pageids\": pageid,\n            \"format\": \"json\",\n        },\n        headers=settings[\"header\"],\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        # pageid can be returned as an int\n        if \"pageimage\" in jsd[\"query\"][\"pages\"][str(pageid)]:\n            image = \"File:\" + jsd[\"query\"][\"pages\"][str(pageid)][\"pageimage\"]\n            r = requests.get(\n                settings[\"apiurl\"],\n                params={\n                    \"action\": \"query\",\n                    \"prop\": \"imageinfo\",\n                    \"iiprop\": \"url\",\n                    \"titles\": image,\n                    \"format\": \"json\",\n                },\n                headers=settings[\"header\"],\n            )\n\n            try:\n                jsd = ujson.loads(r.text)\n            except ValueError:\n                return None\n            else:\n                return jsd[\"query\"][\"pages\"][list(jsd[\"query\"][\"pages\"].keys())[0]][\n                    \"imageinfo\"\n                ][0][\"url\"]\n        else:\n            return None\n</code></pre>"},{"location":"autogen/ln/#pymoelngetwlnupdates","title":"pymoe.ln.get.wlnupdates","text":""},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.settings","title":"<code>settings = {'apiurl': 'https://www.wlnupdates.com/api', 'header': {'User-Agent': 'Pymoe (github.com/ccubed/Pymoe)', 'Content-Type': 'application/json', 'Accept': 'application/json'}}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.artist","title":"<code>artist(item_id)</code>","text":"<p>Given an item_id, get information about the artist with that item_id.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Artist we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def artist(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the artist with that item_id.\n\n    :param item_id: The ID of the Artist we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-artist-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.author","title":"<code>author(item_id)</code>","text":"<p>Given an item_id, get information about the author with that item_id.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Author we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def author(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the author with that item_id.\n\n    :param item_id: The ID of the Author we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-author-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.genre","title":"<code>genre(item_id)</code>","text":"<p>Given an item_id, get information about the genre with that item_id. This actually returns all series with that genre along with the genre itself.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Genre we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def genre(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the genre with that item_id.\n    This actually returns all series with that genre along with the genre itself.\n\n    :param item_id: The ID of the Genre we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-genre-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.group","title":"<code>group(item_id)</code>","text":"<p>Given an item_id, get information about the group with that item_id. This appears to be scanlators/translators.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Group we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def group(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the group with that item_id.\n    This appears to be scanlators/translators.\n\n    :param item_id: The ID of the Group we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-group-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.publisher","title":"<code>publisher(item_id)</code>","text":"<p>Given an item_id, get information about the publisher with that item_id.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Publisher we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def publisher(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the publisher with that item_id.\n\n    :param item_id: The ID of the Publisher we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-publisher-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.series","title":"<code>series(item_id)</code>","text":"<p>Given an item_id, get information about the series with that item_id.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Series we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def series(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the series with that item_id.\n\n    :param item_id: The ID of the Series we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-series-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.get.wlnupdates.tag","title":"<code>tag(item_id)</code>","text":"<p>Given an item_id, get information about the tag with that item_id. This actually returns all series with that tag along with the tag itself.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the Artist we want</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\ln\\get\\wlnupdates.py</code> <pre><code>def tag(item_id: int):\n    \"\"\"\n    Given an item_id, get information about the tag with that item_id.\n    This actually returns all series with that tag along with the tag itself.\n\n    :param item_id: The ID of the Artist we want\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"id\": item_id, \"mode\": \"get-tag-id\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoelnsearch","title":"pymoe.ln.search","text":""},{"location":"autogen/ln/#pymoe.ln.search.series","title":"<code>series(title)</code>","text":"<p>Return a title search for title against WLNUpdates</p> Source code in <code>pymoe\\ln\\search\\__init__.py</code> <pre><code>def series(title: str):\n    \"\"\"\n    Return a title search for title against WLNUpdates\n    \"\"\"\n    return wlnupdates.series(title)\n</code></pre>"},{"location":"autogen/ln/#pymoelnsearchbakatsuki","title":"pymoe.ln.search.bakatsuki","text":""},{"location":"autogen/ln/#pymoe.ln.search.bakatsuki.settings","title":"<code>settings = {'apiurl': 'https://www.baka-tsuki.org/project/api.php', 'header': {'User-Agent': 'Pymoe (github.com/ccubed/Pymoe)'}}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/ln/#pymoe.ln.search.bakatsuki.lightNovels","title":"<code>lightNovels(language='English')</code>","text":"<p>Get a list of light novels under a certain language.</p> PARAMETER  DESCRIPTION <code>language</code> <p>Defaults to English. Replace with whatever language you want to query. You can check their site for the language attributes.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'English'</code> </p> RETURNS DESCRIPTION <p>A list of tuples containing a title and pageid element in that order.</p> Source code in <code>pymoe\\ln\\search\\bakatsuki.py</code> <pre><code>def lightNovels(language: str = \"English\"):\n    \"\"\"\n    Get a list of light novels under a certain language.\n\n    :param str language: Defaults to English. Replace with whatever language you want to query. You can check their site for the language attributes.\n    :return list: A list of tuples containing a title and pageid element in that order.\n    \"\"\"\n    projects = []\n\n    r = requests.get(\n        settings[\"apiurl\"],\n        params={\n            \"action\": \"query\",\n            \"list\": \"categorymembers\",\n            \"cmtitle\": \"Category:Light_novel_({})\".format(language.replace(\" \", \"_\")),\n            \"cmtype\": \"page\",\n            \"cmlimit\": \"500\",\n            \"format\": \"json\",\n        },\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n    else:\n        try:\n            jsd = ujson.loads(r.text)\n        except ValueError:\n            raise serializationFailed(r.text, r.status_code)\n        else:\n            projects.append(\n                [(x[\"title\"], x[\"pageid\"]) for x in jsd[\"query\"][\"categorymembers\"]]\n            )\n\n            if \"query-continue\" in jsd:\n                while True:\n                    r = requests.get(\n                        settings[\"apiurl\"],\n                        params={\n                            \"action\": \"query\",\n                            \"list\": \"categorymembers\",\n                            \"cmtitle\": \"Category:Light_novel_({})\".format(\n                                language.replace(\" \", \"_\")\n                            ),\n                            \"cmtype\": \"page\",\n                            \"cmlimit\": \"500\",\n                            \"cmcontinue\": jsd[\"query-continue\"][\"categorymembers\"][\n                                \"cmcontinue\"\n                            ],\n                            \"format\": \"json\",\n                        },\n                        headers=settings[\"header\"],\n                    )\n\n                    if r.status_code != 200:\n                        break\n                    else:\n                        try:\n                            jsd = ujson.loads(r.text)\n                        except ValueError:\n                            break\n                        else:\n                            projects.append(\n                                [\n                                    (x[\"title\"], x[\"pageid\"])\n                                    for x in jsd[\"query\"][\"categorymembers\"]\n                                ]\n                            )\n                            if \"query-continue\" not in jsd:\n                                break\n\n            return projects[0]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.search.bakatsuki.teasers","title":"<code>teasers(language='English')</code>","text":"<p>Get a list of teaser projects under a certain language.</p> PARAMETER  DESCRIPTION <code>language</code> <p>Defaults to English. Replace with whatever language you want to query.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'English'</code> </p> RETURNS DESCRIPTION <p>A list of tuples containing a title and pageid element in that order.</p> Source code in <code>pymoe\\ln\\search\\bakatsuki.py</code> <pre><code>def teasers(language: str = \"English\"):\n    \"\"\"\n    Get a list of teaser projects under a certain language.\n\n    :param str language: Defaults to English. Replace with whatever language you want to query.\n    :return list: A list of tuples containing a title and pageid element in that order.\n    \"\"\"\n    projects = []\n\n    r = requests.get(\n        settings[\"apiurl\"],\n        params={\n            \"action\": \"query\",\n            \"list\": \"categorymembers\",\n            \"cmtitle\": \"Category:Teaser_({})\".format(language.replace(\" \", \"_\")),\n            \"cmtype\": \"page\",\n            \"cmlimit\": \"500\",\n            \"format\": \"json\",\n        },\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n    else:\n        try:\n            jsd = ujson.loads(r.text)\n        except ValueError:\n            raise serializationFailed(r.text, r.status_code)\n        else:\n            projects.append(\n                [(x[\"title\"], x[\"pageid\"]) for x in jsd[\"query\"][\"categorymembers\"]]\n            )\n\n            if \"query-continue\" in jsd:\n                while True:\n                    r = requests.get(\n                        settings[\"apiurl\"],\n                        params={\n                            \"action\": \"query\",\n                            \"list\": \"categorymembers\",\n                            \"cmtitle\": \"Category:Teaser_({})\".format(\n                                language.replace(\" \", \"_\")\n                            ),\n                            \"cmtype\": \"page\",\n                            \"cmlimit\": \"500\",\n                            \"cmcontinue\": jsd[\"query-continue\"][\"categorymembers\"][\n                                \"cmcontinue\"\n                            ],\n                            \"format\": \"json\",\n                        },\n                        headers=settings[\"header\"],\n                    )\n\n                    if r.status_code != 200:\n                        break\n                    else:\n                        try:\n                            jsd = ujson.loads(r.text)\n                        except ValueError:\n                            break\n                        else:\n                            projects.append(\n                                [\n                                    (x[\"title\"], x[\"pageid\"])\n                                    for x in jsd[\"query\"][\"categorymembers\"]\n                                ]\n                            )\n                            if \"query-continue\" not in jsd:\n                                break\n\n            return projects[0]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.search.bakatsuki.webNovels","title":"<code>webNovels(language='English')</code>","text":"<p>Get a list of web novels under a certain language.</p> PARAMETER  DESCRIPTION <code>language</code> <p>Defaults to English. Replace with whatever language you want to query.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'English'</code> </p> RETURNS DESCRIPTION <p>A list of tuples containing a title and pageid element in that order.</p> Source code in <code>pymoe\\ln\\search\\bakatsuki.py</code> <pre><code>def webNovels(language: str = \"English\"):\n    \"\"\"\n    Get a list of web novels under a certain language.\n\n    :param str language: Defaults to English. Replace with whatever language you want to query.\n    :return list: A list of tuples containing a title and pageid element in that order.\n    \"\"\"\n    projects = []\n\n    r = requests.get(\n        settings[\"apiurl\"],\n        params={\n            \"action\": \"query\",\n            \"list\": \"categorymembers\",\n            \"cmtitle\": \"Category:Web_novel_({})\".format(language.replace(\" \", \"_\")),\n            \"cmtype\": \"page\",\n            \"cmlimit\": \"500\",\n            \"format\": \"json\",\n        },\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n    else:\n        try:\n            jsd = ujson.loads(r.text)\n        except ValueError:\n            raise serializationFailed(r.text, r.status_code)\n        else:\n            projects.append(\n                [(x[\"title\"], x[\"pageid\"]) for x in jsd[\"query\"][\"categorymembers\"]]\n            )\n\n            if \"query-continue\" in jsd:\n                while True:\n                    r = requests.get(\n                        settings[\"apiurl\"],\n                        params={\n                            \"action\": \"query\",\n                            \"list\": \"categorymembers\",\n                            \"cmtitle\": \"Category:Web_novel_({})\".format(\n                                language.replace(\" \", \"_\")\n                            ),\n                            \"cmtype\": \"page\",\n                            \"cmlimit\": \"500\",\n                            \"cmcontinue\": jsd[\"query-continue\"][\"categorymembers\"][\n                                \"cmcontinue\"\n                            ],\n                            \"format\": \"json\",\n                        },\n                        headers=settings[\"header\"],\n                    )\n\n                    if r.status_code != 200:\n                        break\n                    else:\n                        try:\n                            jsd = ujson.loads(r.text)\n                        except ValueError:\n                            break\n                        else:\n                            projects.append(\n                                [\n                                    (x[\"title\"], x[\"pageid\"])\n                                    for x in jsd[\"query\"][\"categorymembers\"]\n                                ]\n                            )\n                            if \"query-continue\" not in jsd:\n                                break\n\n            return projects[0]\n</code></pre>"},{"location":"autogen/ln/#pymoelnsearchwlnupdates","title":"pymoe.ln.search.wlnupdates","text":""},{"location":"autogen/ln/#pymoe.ln.search.wlnupdates.settings","title":"<code>settings = {'apiurl': 'https://www.wlnupdates.com/api', 'header': {'User-Agent': 'Pymoe (github.com/ccubed/Pymoe)', 'Content-Type': 'application/json', 'Accept': 'application/json'}}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/ln/#pymoe.ln.search.wlnupdates.genres","title":"<code>genres()</code>","text":"<p>This simply returns a list of all genres along with their IDs. These are the genres you can use in Parametric search. You can also use these in pymoe.ln.get.wlnupdates.genre</p> Source code in <code>pymoe\\ln\\search\\wlnupdates.py</code> <pre><code>def genres():\n    \"\"\"\n    This simply returns a list of all genres along with their IDs.\n    These are the genres you can use in Parametric search.\n    You can also use these in pymoe.ln.get.wlnupdates.genre\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"], headers=settings[\"header\"], json={\"mode\": \"enumerate-genres\"}\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.search.wlnupdates.parametric","title":"<code>parametric(title_search_text=None, tag_category=None, genre_category=None, chapter_limits=None, series_type=None, sort_mode='name', include_results=None)</code>","text":"<p>Perform a Parametric search. This is the search-advanced route. You have to pass at least one of tags or genres. If you don't, this function will refer your search to title search. If you don't need to search by tags or genres, title search is a better option per the api documentation. The parameters have the same name as the API due to how the query is built.</p> PARAMETER  DESCRIPTION <code>title-search-text</code> <p>Optional title to search by</p> <p> </p> <code>tags</code> <p>A dictionary consisting of pairs of 'tag' keys and then 'included' or 'excluded'</p> <p> </p> <code>genres</code> <p>A dictionary consisting of pairs of 'genre' keys and then 'included' or 'excluded'</p> <p> </p> <code>chapter_limit</code> <p>A tuple consisting of (minimum,maximum) to limit by chapter count. Passing 0 disables the limit it was passed for.</p> <p> </p> <code>series_type</code> <p>A dictionary consisting of the keys 'Translated' and 'Original English Language' along with Included or Excluded as the value for each.</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>sort_mode</code> <p>One of update, chapter-count, or name. Defaults to name.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'name'</code> </p> <code>include_results</code> <p>A list of strings to represent what additional information to return. Only accepts description, covers, tags, genres.</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> Source code in <code>pymoe\\ln\\search\\wlnupdates.py</code> <pre><code>def parametric(\n    title_search_text: str = None,\n    tag_category=None,\n    genre_category: Dict = None,\n    chapter_limits: tuple = None,\n    series_type: Dict = None,\n    sort_mode: str = \"name\",\n    include_results: Dict = None,\n):\n    \"\"\"\n    Perform a Parametric search. This is the search-advanced route.\n    You have to pass at least one of tags or genres. If you don't, this function will refer your search to title search.\n    If you don't need to search by tags or genres, title search is a better option per the api documentation.\n    The parameters have the same name as the API due to how the query is built.\n\n    :param title-search-text: Optional title to search by\n    :param tags: A dictionary consisting of pairs of 'tag' keys and then 'included' or 'excluded'\n    :param genres: A dictionary consisting of pairs of 'genre' keys and then 'included' or 'excluded'\n    :param chapter_limit: A tuple consisting of (minimum,maximum) to limit by chapter count. Passing 0 disables the limit it was passed for.\n    :param series_type: A dictionary consisting of the keys 'Translated' and 'Original English Language' along with Included or Excluded as the value for each.\n    :param sort_mode: One of update, chapter-count, or name. Defaults to name.\n    :param include_results: A list of strings to represent what additional information to return. Only accepts description, covers, tags, genres.\n    \"\"\"\n    if not (tag_category or genre_category):\n        if title_search_text:\n            return series(title_search_text)\n        else:\n            raise ValueError(\n                \"pymoe.ln.search.wlnupdates.parametric: Requires one of tag_category or genre_category.\"\n            )\n\n    json_data = {\"mode\": \"search-advanced\"}\n\n    args, _, _, values = getargvalues(currentframe())\n\n    for item in args:\n        if values[item]:\n            json_data[item.replace(\"_\", \"-\")] = values[item]\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_data)\n\n    print(r.text)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.search.wlnupdates.series","title":"<code>series(title_text)</code>","text":"<p>Given the title_text to search by, return a list of results. This is the best method to find a title by name.</p> PARAMETER  DESCRIPTION <code>title_text</code> <p>The title to search for.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymoe\\ln\\search\\wlnupdates.py</code> <pre><code>def series(title_text: str):\n    \"\"\"\n    Given the title_text to search by, return a list of results.\n    This is the best method to find a title by name.\n\n    :param title_text: The title to search for.\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"],\n        headers=settings[\"header\"],\n        json={\"title\": title_text, \"mode\": \"search-title\"},\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/ln/#pymoe.ln.search.wlnupdates.tags","title":"<code>tags()</code>","text":"<p>This simply returns a list of all tags along with their IDs. These are the tags you can use in Parametric search. You can also use these in pymoe.ln.get.wlnupdates.tag</p> Source code in <code>pymoe\\ln\\search\\wlnupdates.py</code> <pre><code>def tags():\n    \"\"\"\n    This simply returns a list of all tags along with their IDs.\n    These are the tags you can use in Parametric search.\n    You can also use these in pymoe.ln.get.wlnupdates.tag\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"], headers=settings[\"header\"], json={\"mode\": \"enumerate-tags\"}\n    )\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"error\"]:\n            raise serverError(jsd[\"message\"], r.status_code)\n        else:\n            return jsd[\"data\"]\n</code></pre>"},{"location":"autogen/manga/","title":"Manga Classes","text":""},{"location":"autogen/manga/#pymoemangaget","title":"pymoe.manga.get","text":""},{"location":"autogen/manga/#pymoe.manga.get.character","title":"<code>character(item_id)</code>","text":"Source code in <code>pymoe\\manga\\get\\__init__.py</code> <pre><code>def character(item_id: int):\n    return anilist.character(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.manga","title":"<code>manga(item_id)</code>","text":"Source code in <code>pymoe\\manga\\get\\__init__.py</code> <pre><code>def manga(item_id: int):\n    return anilist.manga(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.staff","title":"<code>staff(item_id)</code>","text":"Source code in <code>pymoe\\manga\\get\\__init__.py</code> <pre><code>def staff(item_id: int):\n    return anilist.staff(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoemangagetanilist","title":"pymoe.manga.get.anilist","text":""},{"location":"autogen/manga/#pymoe.manga.get.anilist.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json'}, 'apiurl': 'https://graphql.anilist.co'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/manga/#pymoe.manga.get.anilist.character","title":"<code>character(item_id)</code>","text":"<p>Anilist does not separate characters by anime/manga. This is simply a reference to the character function that already exists.</p> Source code in <code>pymoe\\manga\\get\\anilist.py</code> <pre><code>def character(item_id: int):\n    \"\"\"\n    Anilist does not separate characters by anime/manga.\n    This is simply a reference to the character function that already exists.\n    \"\"\"\n    return cref(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.anilist.manga","title":"<code>manga(item_id)</code>","text":"<p>The function to retrieve a manga's details. I really couldn't think of another name for this.</p> Source code in <code>pymoe\\manga\\get\\anilist.py</code> <pre><code>def manga(item_id: int):\n    \"\"\"\n    The function to retrieve a manga's details.\n    I really couldn't think of another name for this.\n    \"\"\"\n    query_string = \"\"\"\\\n        query( $id: Int ) {\n            Media( id: $id, type: MANGA ) {\n                idMal\n                title {\n                    romaji\n                    english\n                }\n                status\n                description\n                startDate {\n                    year\n                    month\n                    day\n                }\n                endDate {\n                    year\n                    month\n                    day\n                }\n                coverImage {\n                    extraLarge\n                    large\n                    medium\n                    color\n                }\n                chapters\n                volumes\n                genres\n                synonyms\n                averageScore\n                isAdult\n                siteUrl\n                popularity\n                characters {\n                    nodes {\n                        id\n                        name {\n                            first\n                            last\n                        }\n                        image {\n                            large\n                            medium\n                        }\n                        description\n                        gender\n                        age\n                        siteUrl\n                    }\n                }\n            }\n        }        \n    \"\"\"\n\n    json_params = {\"query\": query_string, \"variables\": {\"id\": item_id}}\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.anilist.staff","title":"<code>staff(item_id)</code>","text":"<p>Anilist does not separate staff by anime/manga. This is simply a reference to the staff function that already exists.</p> Source code in <code>pymoe\\manga\\get\\anilist.py</code> <pre><code>def staff(item_id: int):\n    \"\"\"\n    Anilist does not separate staff by anime/manga.\n    This is simply a reference to the staff function that already exists.\n    \"\"\"\n    return sref(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoemangagetkitsu","title":"pymoe.manga.get.kitsu","text":""},{"location":"autogen/manga/#pymoe.manga.get.kitsu.settings","title":"<code>settings = {'header': {'Content-Type': 'application/vnd.api+json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/vnd.api+json'}, 'apiurl': 'https://kitsu.io/api/edge'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/manga/#pymoe.manga.get.kitsu.manga","title":"<code>manga(item_id)</code>","text":"<p>Get information on the given manga by ID.</p> PARAMETER  DESCRIPTION <code>item_id</code> <p>The ID of the manga you want information on</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\kitsu.py</code> <pre><code>def manga(item_id: int):\n    \"\"\"\n    Get information on the given manga by ID.\n\n    :param item_id: The ID of the manga you want information on\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/manga/{}\".format(item_id), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        if r.status_code == 404:\n            return None\n        else:\n            raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoemangagetmangaupdates","title":"pymoe.manga.get.mangaupdates","text":""},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json'}, 'apiurl': 'https://api.mangaupdates.com/v1/'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.author","title":"<code>author(authorId)</code>","text":"<p>Get a specific author by ID</p> PARAMETER  DESCRIPTION <code>authorId</code> <p>The author ID to get data for.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def author(authorId: int):\n    \"\"\"\n    Get a specific author by ID\n\n    :param authorId: The author ID to get data for.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"authors/{}\".format(authorId), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.genres","title":"<code>genres()</code>","text":"<p>Get a list of all genres. Note that this literally returns all genres as a list of dictionaries.</p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def genres():\n    \"\"\"\n    Get a list of all genres.\n    Note that this literally returns all genres as a list of dictionaries.\n    \"\"\"\n    r = requests.get(settings[\"apiurl\"] + \"genres\", headers=settings[\"header\"])\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.group","title":"<code>group(groupId)</code>","text":"<p>Get a specific group by ID</p> PARAMETER  DESCRIPTION <code>groupId</code> <p>The group ID to get data for.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def group(groupId: int):\n    \"\"\"\n    Get a specific group by ID\n\n    :param groupId: The group ID to get data for.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"groups/{}\".format(groupId), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.groupsByManga","title":"<code>groupsByManga(seriesId)</code>","text":"<p>Get a list of groups that have worked on a series</p> PARAMETER  DESCRIPTION <code>seriesId</code> <p>The Series to find groups for</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def groupsByManga(seriesId: int):\n    \"\"\"\n    Get a list of groups that have worked on a series\n\n    :param seriesId: The Series to find groups for\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"series/{}/groups\".format(seriesId),\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.manga","title":"<code>manga(seriesId)</code>","text":"<p>Get a specific series by series ID.</p> PARAMETER  DESCRIPTION <code>seriesId</code> <p>The Series ID to get data for.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def manga(seriesId: int):\n    \"\"\"\n    Get a specific series by series ID.\n\n    :param seriesId: The Series ID to get data for.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"series/{}\".format(seriesId), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.mangaByAuthor","title":"<code>mangaByAuthor(authorId)</code>","text":"<p>Get a list of series an author has worked on</p> PARAMETER  DESCRIPTION <code>authorId</code> <p>The author ID to get data for.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def mangaByAuthor(authorId: int):\n    \"\"\"\n    Get a list of series an author has worked on\n\n    :param authorId: The author ID to get data for.\n    \"\"\"\n    r = requests.post(\n        settings[\"apiurl\"] + \"authors/{}/series\".format(authorId),\n        headers=settings[\"header\"],\n        json={\"orderby\": \"title\"},\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.mangaReleaseFeed","title":"<code>mangaReleaseFeed(seriesId)</code>","text":"<p>Get an RSS Feed of Releases for a specific series</p> PARAMETER  DESCRIPTION <code>seriesId</code> <p>The Series ID to get a feed for</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def mangaReleaseFeed(seriesId: int):\n    \"\"\"\n    Get an RSS Feed of Releases for a specific series\n\n    :param seriesId: The Series ID to get a feed for\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"series/{}/rss\".format(seriesId), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    # This is simply XML data.\n    return r.text\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.publisher","title":"<code>publisher(publisherId)</code>","text":"<p>Get a specific publisher by ID</p> PARAMETER  DESCRIPTION <code>publisherId</code> <p>The Publisher ID to get data for.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def publisher(publisherId: int):\n    \"\"\"\n    Get a specific publisher by ID\n\n    :param publisherId: The Publisher ID to get data for.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"publishers/{}\".format(publisherId),\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.releasesFeed","title":"<code>releasesFeed()</code>","text":"<p>Get an RSS Feed of Releases for the entire site</p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def releasesFeed():\n    \"\"\"\n    Get an RSS Feed of Releases for the entire site\n    \"\"\"\n    r = requests.get(settings[\"apiurl\"] + \"releases/rss\", headers=settings[\"header\"])\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    # This is simply XML data.\n    return r.text\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.get.mangaupdates.review","title":"<code>review(reviewId)</code>","text":"<p>Get a specific review by ID</p> PARAMETER  DESCRIPTION <code>reviewId</code> <p>The Review ID to get data for.</p> <p> TYPE: <code>int</code> </p> Source code in <code>pymoe\\manga\\get\\mangaupdates.py</code> <pre><code>def review(reviewId: int):\n    \"\"\"\n    Get a specific review by ID\n\n    :param reviewId: The Review ID to get data for.\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"reviews/{}\".format(reviewId), headers=settings[\"header\"]\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoemangasearch","title":"pymoe.manga.search","text":""},{"location":"autogen/manga/#pymoe.manga.search.manga","title":"<code>manga(title)</code>","text":"Source code in <code>pymoe\\manga\\search\\__init__.py</code> <pre><code>def manga(title: str):\n    return anilist.manga(title)\n</code></pre>"},{"location":"autogen/manga/#pymoemangasearchanilist","title":"pymoe.manga.search.anilist","text":""},{"location":"autogen/manga/#pymoe.manga.search.anilist.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json'}, 'apiurl': 'https://graphql.anilist.co'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/manga/#pymoe.manga.search.anilist.characters","title":"<code>characters(item_id)</code>","text":"<p>Anilist does not separate characters by anime/manga. This is simply a reference to the character function that already exists.</p> Source code in <code>pymoe\\manga\\search\\anilist.py</code> <pre><code>def characters(item_id: int):\n    \"\"\"\n    Anilist does not separate characters by anime/manga.\n    This is simply a reference to the character function that already exists.\n    \"\"\"\n    return cref(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.anilist.manga","title":"<code>manga(term, page=1, perPage=3)</code>","text":"<p>Search for manga that match term in the kitsu api.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> <code>page</code> <p>Which page of results?</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>How many results per page?</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>pymoe\\manga\\search\\anilist.py</code> <pre><code>def manga(term: str, page: int = 1, perPage: int = 3):\n    \"\"\"\n    Search for manga that match term in the kitsu api.\n\n    :param term: Search Term\n    :param page: Which page of results?\n    :param perPage: How many results per page?\n    \"\"\"\n    query_string = \"\"\"\\\n        query( $query: String, $page: Int, $perPage: Int ){\n            Page ( page: $page, perPage: $perPage ) {\n                pageInfo {\n                    currentPage\n                    hasNextPage\n                }\n                media ( search: $query, type: MANGA ){\n                    id\n                    idMal\n                    title {\n                        romaji\n                        english\n                    }\n                    coverImage {\n                        extraLarge\n                        large\n                        medium\n                        color\n                    }\n                    status\n                    description\n                    startDate {\n                        year\n                        month\n                        day\n                    }\n                    endDate {\n                        year\n                        month\n                        day\n                    }\n                    averageScore\n                    popularity\n                    chapters\n                    volumes\n                    genres\n                    hashtag\n                    isAdult\n                    averageScore\n                    synonyms\n                    siteUrl\n                }\n            }\n        }    \n    \"\"\"\n\n    json_params = {\n        \"query\": query_string,\n        \"variables\": {\"query\": term, \"page\": page, \"perPage\": perPage},\n    }\n\n    r = requests.post(settings[\"apiurl\"], headers=settings[\"header\"], json=json_params)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if \"errors\" in jsd:\n            raise serverError(r.text, r.status_code)\n        else:\n            if jsd[\"data\"][\"Page\"][\"pageInfo\"][\"hasNextPage\"]:\n                return anilistWrapper(\n                    jsd[\"data\"][\"Page\"][\"media\"],\n                    json_params,\n                    settings[\"header\"],\n                    settings[\"apiurl\"],\n                )\n            else:\n                return jsd[\"data\"][\"Page\"][\"media\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.anilist.staff","title":"<code>staff(item_id)</code>","text":"<p>Anilist does not separate staff by anime/manga. This is simply a reference to the staff function that already exists.</p> Source code in <code>pymoe\\manga\\search\\anilist.py</code> <pre><code>def staff(item_id: int):\n    \"\"\"\n    Anilist does not separate staff by anime/manga.\n    This is simply a reference to the staff function that already exists.\n    \"\"\"\n    return sref(item_id)\n</code></pre>"},{"location":"autogen/manga/#pymoemangasearchkitsu","title":"pymoe.manga.search.kitsu","text":""},{"location":"autogen/manga/#pymoe.manga.search.kitsu.settings","title":"<code>settings = {'header': {'Content-Type': 'application/vnd.api+json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/vnd.api+json'}, 'apiurl': 'https://kitsu.io/api/edge'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/manga/#pymoe.manga.search.kitsu.manga","title":"<code>manga(term)</code>","text":"<p>Search for manga that match the search term in the Kitsu API.</p> PARAMETER  DESCRIPTION <code>term</code> <p>Search Term</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymoe\\manga\\search\\kitsu.py</code> <pre><code>def manga(term: str):\n    \"\"\"\n    Search for manga that match the search term in the Kitsu API.\n\n    :param term: Search Term\n    \"\"\"\n    r = requests.get(\n        settings[\"apiurl\"] + \"/manga\",\n        params={\"filter[text]\": term},\n        headers=settings[\"header\"],\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"meta\"][\"count\"]:\n            return kitsuWrapper(\n                jsd[\"data\"],\n                jsd[\"links\"][\"next\"] if \"next\" in jsd[\"links\"] else None,\n                settings[\"header\"],\n            )\n        else:\n            return jsd\n</code></pre>"},{"location":"autogen/manga/#pymoemangasearchmangaupdates","title":"pymoe.manga.search.mangaupdates","text":""},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.settings","title":"<code>settings = {'header': {'Content-Type': 'application/json', 'User-Agent': 'Pymoe (github.com/ccubed/PyMoe)', 'Accept': 'application/json'}, 'apiurl': 'https://api.mangaupdates.com/v1/'}</code>  <code>module-attribute</code>","text":""},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.authors","title":"<code>authors(title, options=None, page=1, perPage=5)</code>","text":"<p>Search for Authors that match the title. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>title</code> <p>The name of the Author to find</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def authors(title: str, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for Authors that match the title.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param title: The name of the Author to find\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"search\"] = title\n        thisData[\"page\"] = page\n        thisData[\"perPage\"] = perPage\n    else:\n        thisData = {\"search\": title, \"page\": page, \"perPage\": perPage}\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"authors/search\", headers=settings[\"header\"], json=thisData\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.categories","title":"<code>categories(title, options=None, page=1, perPage=5)</code>","text":"<p>Search for Categories that match the title. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>title</code> <p>The name of the Category to find</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def categories(title: str, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for Categories that match the title.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param title: The name of the Category to find\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"search\"] = title\n        thisData[\"page\"] = page\n        thisData[\"perpage\"] = perPage\n    else:\n        thisData = {\"search\": title, \"page\": page, \"perPage\": perPage}\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"categories/search\",\n        headers=settings[\"header\"],\n        json=thisData,\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.groups","title":"<code>groups(title, options=None, page=1, perPage=5)</code>","text":"<p>Search for Groups that match the title. Groups are scanlators, uploaders, raw providers, etc. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>title</code> <p>The name of the group to find</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def groups(title: str, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for Groups that match the title.\n    Groups are scanlators, uploaders, raw providers, etc.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param title: The name of the group to find\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"search\"] = title\n        thisData[\"page\"] = page\n        thisData[\"perPage\"] = perPage\n    else:\n        thisData = {\"search\": title, \"page\": page, \"perPage\": perPage}\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"groups/search\", headers=settings[\"header\"], json=thisData\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.manga","title":"<code>manga(title, options=None, page=1, perPage=5)</code>","text":"<p>Search for a series with title on Mangaupdates. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>title</code> <p>The title to search for</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def manga(title: str, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for a series with title on Mangaupdates.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param title: The title to search for\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"search\"] = title\n        thisData[\"page\"] = page\n        thisData[\"perPage\"] = perPage\n    else:\n        thisData = {\"search\": title, \"page\": page, \"perPage\": perPage}\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"series/search\", headers=settings[\"header\"], json=thisData\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.publishers","title":"<code>publishers(title, options=None, page=1, perPage=5)</code>","text":"<p>Search for Publishers that match the title. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>title</code> <p>The name of the publisher to find</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def publishers(title: str, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for Publishers that match the title.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param title: The name of the publisher to find\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"search\"] = title\n        thisData[\"page\"] = page\n        thisData[\"perPage\"] = perPage\n    else:\n        thisData = {\"search\": title, \"page\": page, \"perPage\": perPage}\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"publishers/search\",\n        headers=settings[\"header\"],\n        json=thisData,\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.releases","title":"<code>releases(seriesId, options=None, page=1, perPage=5)</code>","text":"<p>Search for releases for a specific series ID. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>seriesId</code> <p>The Series ID to find releases for</p> <p> TYPE: <code>int</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def releases(seriesId: int, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for releases for a specific series ID.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param seriesId: The Series ID to find releases for\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"search\"] = str(seriesId)\n        thisData[\"search_type\"] = \"series\"\n        thisData[\"page\"] = page\n        thisData[\"perPage\"] = perPage\n    else:\n        thisData = {\n            \"search\": str(seriesId),\n            \"search_type\": \"series\",\n            \"page\": page,\n            \"perPage\": perPage,\n        }\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"releases/search\", headers=settings[\"header\"], json=thisData\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"autogen/manga/#pymoe.manga.search.mangaupdates.reviews","title":"<code>reviews(seriesId, options=None, page=1, perPage=5)</code>","text":"<p>Search for reviews for a given series ID. Options is an optional dictionary containing additional search options to pass.</p> PARAMETER  DESCRIPTION <code>seriesId</code> <p>The ID of the series to get reviews for</p> <p> TYPE: <code>int</code> </p> <code>options</code> <p>An optional dictionary of additional search criteria</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>page</code> <p>Which page of results</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>perPage</code> <p>Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> Source code in <code>pymoe\\manga\\search\\mangaupdates.py</code> <pre><code>def reviews(seriesId: int, options: Dict = None, page: int = 1, perPage: int = 5):\n    \"\"\"\n    Search for reviews for a given series ID.\n    Options is an optional dictionary containing additional search options to pass.\n\n    :param seriesId: The ID of the series to get reviews for\n    :param options: An optional dictionary of additional search criteria\n    :param page: Which page of results\n    :param perPage: Results per page. Note that the only acceptable values are 5,10,15,25,30,40,50,75,100\n    \"\"\"\n    thisData = None\n    if options:\n        thisData = options\n        thisData[\"series_id\"] = str(seriesId)\n        thisData[\"page\"] = page\n        thisData[\"perPage\"] = perPage\n    else:\n        thisData = {\"series_id\": str(seriesId), \"page\": page, \"perPage\": perPage}\n\n    r = requests.post(\n        settings[\"apiurl\"] + \"reviews/search\", headers=settings[\"header\"], json=thisData\n    )\n\n    if r.status_code != 200:\n        raise serverError(r.text, r.status_code)\n\n    try:\n        jsd = ujson.loads(r.text)\n    except ValueError:\n        raise serializationFailed(r.text, r.status_code)\n    else:\n        if jsd[\"total_hits\"] &gt; jsd[\"per_page\"]:\n            return mangaupdatesWrapper(\n                jsd[\"results\"],\n                settings[\"apiurl\"] + \"series/search\",\n                settings[\"header\"],\n                thisData,\n                round(jsd[\"total_hits\"] / jsd[\"per_page\"], 0),\n            )\n        else:\n            return jsd[\"results\"]\n</code></pre>"},{"location":"ln/bakatsuki/","title":"Pymoe.LN - Bakatsuki","text":"<p>This is the documentation for the Bakatsuki module of Pymoe.LN.</p>"},{"location":"ln/bakatsuki/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> cover, active, chapters <code>SEARCH</code> lightNovels, teasers, webNovels <p>Bakatsuki is actually a wiki and we get information from it by using the built in mediawiki api. This means it is slow. Even using the API, some information, such as chapters, has to be manually pulled from the HTML source. The searches and active endpoints are just getting lists of categories back from the API and formatting them into tuples, so those are fairly fast. If you do use cover or chapters, be prepared for it to take up to a few seconds to extract the data.</p>"},{"location":"ln/bakatsuki/#return-formatting","title":"Return Formatting","text":"<p>Thankfully, I have a lot of control over the return formatting due to how the data is gathered.</p> Endpoint Return Format <code>COVER</code> A single str representing the URL of the cover image <code>ACTIVE</code> A list of tuples in the format (Title, ID) <code>CHAPTERS</code> An OrderedDict keyed by Chapter Numbers and containing a list of lists in the format (Chapter Link, Chapter Title If Any) <code>LIGHTNOVELS</code> A list of tuples in the format (Title, ID) <code>TEASERS</code> A list of tuples in the format (Title, ID) <code>WEBNOVELS</code> A list of tuples in the format (Title, ID)"},{"location":"ln/bakatsuki/#some-notes","title":"Some Notes","text":""},{"location":"ln/bakatsuki/#cover-versus-chapters","title":"Cover versus Chapters","text":"<p>The <code>COVER</code> endpoint expects you to pass it the ID from one of the tuples above. The <code>CHAPTERS</code> endpoint expects you to pass it the Title from one of the tuples above. So <code>COVER</code> is ID, while <code>CHAPTERS</code> is Title. The reason for this is how it gathers the data. Chapters is an HTML scrape so we need the page title (Which is coincidentally the same as the series Title) whereas Cover is an API request for the first image on a given page ID.</p>"},{"location":"ln/bakatsuki/#cover-images","title":"Cover Images","text":"<p>The <code>COVER</code> endpoint is very taxing on the API. It takes several different requests to actually get that data. I have to first query the details for each image on the page. Then find the specific one I need and generate the File ID. Then we have to send that back to the API to get the actual URL the image resides at. I say all this to say that you should add a slight pause between batch operations.</p>"},{"location":"ln/bakatsuki/#some-examples","title":"Some Examples","text":"<pre><code>import time\nimport pymoe\n\n# List all Active Projects and their IDs\nfor project in pymoe.ln.get.bakatsuki.active():\n    print(\"{} with ID {}\".format(project[0], project[1]))\n\n# What if we wanted the cover image of each active project?\nimages = []\nfor project in pymoe.ln.get.bakatsuki.active():\n    images.append(\n        (\n            project[0], # The Title\n            pymoe.ln.get.bakatsuki.cover(project[1]) # The URL to the cover image given a page ID\n        )\n    )\n    time.sleep(0.5)\nprint(images)\n</code></pre>"},{"location":"ln/start/","title":"Pymoe.LN","text":"<p>What Does Default Mean?</p> <p>Whenever the term default is used, it refers to the top level functions available at pymoe.type.operation.endpoint. So <code>pymoe.anime.get.show</code> or <code>pymoe.manga.search.series</code>.</p> <p>This is the user guide for Pymoe.LN and its submodules. This page will go over the default methods available at pymoe.ln.get and pymoe.ln.search. Further information on the specifics of each module are in their own documents.</p> Module Documentation Location <code>DEFAULT</code> This Page <code>BAKATSUKI</code> Documentation <code>WLNUPDATES</code> Documentation"},{"location":"ln/start/#default-methods","title":"Default Methods","text":"<p>These default methods route through WLNUpdates.</p>"},{"location":"ln/start/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> series, artist, author, group, publisher, genre, tag <code>SEARCH</code> series"},{"location":"ln/start/#get-methods","title":"GET Methods","text":"<p>Genre and Tag</p> <p>Be Warned! You might think that Genre and Tag simply return information about a given Genre or Tag ID. You would be wrong. Genre and Tag actually return all series with that genre or tag along with information about the genre or tag itself. </p> Endpoint Description Provider <code>SERIES</code> Get information on a series given an ID WLNUpdates <code>ARTIST</code> Get information on an artist given an ID WLNUpdates <code>AUTHOR</code> Get information on an author given an ID WLNUpdates <code>PUBLISHER</code> Get information on a publisher given an ID WLNUpdates <code>GENRE</code> See Note WLNUpdates <code>TAG</code> See Note WLNUpdates <p>An Example</p> <pre><code>import pymoe\n\n# Print information about our trusty test series Slam Dunk\nprint(pymoe.ln.get.series(55665151734))\n</code></pre> <p>Return Formatting</p> <p>This is gone over in more detail in the specific documents, but this uses WLNUpdates as the data provider. Luckily, WLNUpdates mostly does not wrap their content up in any special formatting. Your return will just be the json object you requested or a list of json objects matching your query. You can access returned attributes directly. The exception to this rule is searching by title which returns the results as a json object, but hides the list of actual results in the 'results' key. This is the only endpoint that operates slightly differently.</p>"},{"location":"ln/start/#search-methods","title":"SEARCH Methods","text":"<p>There's only one so this will be short.</p> Endpoint Description Provider <code>SERIES</code> Search for series by title WLNUpdates <p>An Example</p> <pre><code>import pymoe\n\n# Search for Dragon and print the title of each matching series\nfor item in pymoe.ln.search.series(\"Dragon\")['results']:\n    print(item['title'])\n</code></pre>"},{"location":"ln/wlnupdates/","title":"WLNUpdates","text":"<p>LN GET     WLNUpdates: series, artist, author, genre, group, publisher, tag SEARCH     WLNUpdates: series, tags, genres, parametric</p>"},{"location":"ln/wlnupdates/#pymoeln-wlnupdates","title":"Pymoe.LN - WLNUpdates","text":"<p>This is the documentation for the WLNUpdates module of Pymoe.LN.</p>"},{"location":"ln/wlnupdates/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> series, artist, author, genre, group, publisher, tag <code>SEARCH</code> series, tags, genres, parametric"},{"location":"ln/wlnupdates/#return-formatting","title":"Return Formatting","text":"<p>Thankfully, WLNUpdates mostly doesn't format their returns. What you get back is either the json object itself or a list of json objects. The only exception to this is the series search method which returns the list of results hidden behind a 'results' key. So the return for search.series only looks like this.</p> <pre><code>{\n    \"results\": [list of json objects],\n    \"cleaned_search\": a string representing the cleaned search title\n}\n</code></pre>"},{"location":"ln/wlnupdates/#some-notes","title":"Some Notes","text":""},{"location":"ln/wlnupdates/#on-tag-and-genre","title":"On Tag and Genre","text":"<p>As noted on the main page, tag and genre do not do what you think. When you search for tags or genres you are going to get back every tag and genre on the site along with associated statistics. When you get a tag or genre you are going to get back every series with that tag or genre along with the name of the tag or genre itself.</p>"},{"location":"ln/wlnupdates/#parametric-searching","title":"Parametric Searching","text":"<p>Parametric is the advanced search endpoint and it requires you to specify at least one of either a list of tags or list of genres to search by. If you don't provide one or the other, you'll either be redirected to title search (assuming you provided a title) or get an error.</p>"},{"location":"ln/wlnupdates/#some-examples","title":"Some Examples","text":"<pre><code>import pymoe\n\n# Prints Death March kara Hajimaru Isekai Kyusoukyoku\nprint(pymoe.ln.get.wlnupdates.series(581)['title'])\n\n# Parametric searching\nresults = pymoe.ln.get.wlnupdates.parametric(\n    # Dictionary with Tags as Keys and included/excluded as value\n    # genre_category is the same thing but with Genres as Keys\n    tag_category={\n        'ability-steal': 'included', \n        'virtual-reality': 'excluded'\n    },\n    # Tuple containing (min, max) chapters to search by. 0 means no limit.\n    chapter_limits=(40,0),\n    # Dictionary that can only include the keys Translated or Original English Language with value Included/Excluded\n    series_type={\n        'Translated': 'included'\n    },\n    # How to sort results. update, chapter-count or name (default) are possible. \n    sort_mode='update',\n    # A list of strings that designates extra data to be included or excluded from the results. This adds cover links to the results.\n    include_results=['covers']\n)\n</code></pre>"},{"location":"manga/anilist/","title":"Pymoe.Manga - Anilist","text":"<p>This is the documentation for the Anilist module of Pymoe.Manga.</p>"},{"location":"manga/anilist/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> manga, character, staff <code>SEARCH</code> manga, characters, staff <p>Anilist mostly only supports getting a manga by ID and searching for a manga by title. Anilist does not separate characters and staff between Anime and Manga, so the character and staff functions here simply refer back to the functions in pymoe.anime.</p>"},{"location":"manga/anilist/#return-formatting","title":"Return Formatting","text":"<p>The biggest piece of advice I can give you on this is to read the GraphQL strings in the source. For example, the GraphQL query for a specific manga is...</p> <pre><code>query( $id: Int ) {\n    Media( id: $id, type: MANGA ) {\n        idMal\n        title {\n            romaji\n            english\n        }\n        status\n        description\n        startDate {\n            year\n            month\n            day\n        }\n        endDate {\n            year\n            month\n            day\n        }\n        coverImage {\n            extraLarge\n            large\n            medium\n            color\n        }\n        chapters\n        volumes\n        genres\n        synonyms\n        averageScore\n        isAdult\n        siteUrl\n        popularity\n        characters {\n            nodes {\n                id\n                name {\n                    first\n                    last\n                }\n                image {\n                    large\n                    medium\n                }\n                description\n                gender\n                age\n                siteUrl\n            }\n        }\n    }\n}\n</code></pre> <p>This also defines the return formatting. For example, if you want the medium coverImage, then the you can get that by doing... <pre><code>import pymoe\n\n# This is Berserk the Manga\nresult = pymoe.manga.get.anilist.manga(30002)\nprint(result['Media']['coverImage']['medium'])\n</code></pre></p> <p>As you can see, it directly follows the build of the query. One thing to be aware of is that nodes is a special keyword for GraphQL that indicates multiple results will be returned. So if we wanted to get the first name of every character attached to this manga, we would do...</p> <p>The Records Appear To Be Incomplete</p> <p>Not all characters have a last name, an age, or a gender. Don't be surprised if these come back as None. </p> <pre><code>import pymoe\n\n# This is Berserk the Manga\nresult = pymoe.manga.get.anilist.manga(30002)\n\nfor character in result['Media']['characters']['nodes']:\n    print(character['name']['first'])\n</code></pre> <p>As a more complex example, let's say that we want to run a get request on each character from this manga. Then we can...</p> <pre><code>import time\nimport pymoe\n\n# This is Berserk the Manga\nresult = pymoe.manga.get.anilist.manga(30002)\n\nmyNewList = []\nfor item in result['Media']['characters']['nodes']:\n    myNewList.append(pymoe.manga.get.anilist.character(item['id']))\n    time.sleep(0.5)\n</code></pre> <p>Why the sleep call? Since this hits an API, you might want to add a slight pause between requests to avoid being rate limited. This library does not manage rate limiting for you. However, it does return the information you need to identify rate limiting.</p>"},{"location":"manga/kitsu/","title":"Pymoe.Manga - Kitsu","text":"<p>This is the documentation for the Kitsu module of Pymoe.Manga.</p>"},{"location":"manga/kitsu/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> manga <code>SEARCH</code> manga <p>Since Kitsu only supports two methods, I won't write in depth documentation for this. You can get a manga by id or you can search for a manga by title. That's it. What you really have to worry about is the return formatting.</p> <p>A Note on Kitsu</p> <p>I really don't recommend using Kitsu. It's here since some apps rely on it, but with searching going away and no promise these endpoints will continue to work you'd be much better off using Anilist or MangaUpdates.</p>"},{"location":"manga/kitsu/#return-formatting","title":"Return Formatting","text":"<p>Kitsu's return formatting is a lot. Let me show you an example.</p> <pre><code>{\n  \"data\": {\n    \"id\": \"14916\",\n    \"type\": \"manga\",\n    \"links\": {\n      \"self\": \"https://kitsu.io/api/edge/manga/14916\"\n    },\n    \"attributes\": {\n      \"createdAt\": \"2013-12-18T13:59:39.232Z\",\n      \"updatedAt\": \"2024-02-15T20:05:44.395Z\",\n      \"slug\": \"shingeki-no-kyojin\",\n      \"synopsis\": \"A century ago, the grotesque giants known as Titans appeared and consumed all but a few thousand humans. The survivors took refuge behind giant walls. Today, the threat of the Titans is a distant memory, and a boy named Eren yearns to explore the world beyond Wall Maria. But what began as a childish dream will become an all-too-real nightmare when the Titans return and humanity is once again on the brink of extinction \u2026 Attack on Titan is the award-winning and New York Times-bestselling series that is the manga hit of the decade! Spawning the monster hit anime TV series of the same name, Attack on Titan has become a pop culture sensation. \\n\\n(Source: Kodansha Comics)\\n\\nVolume 3 contains the special story \\\"Rivai Heishichou\\\" (\u30ea\u30f4\u30a1\u30a4\u5175\u58eb\u9577, Captain Levi).\\nVolume 5 contains the side story \\\"Ilse no Techou\\\" (\u30a4\u30eb\u30bc\u306e\u624b\u5e33, Ilse's Notebook).\",\n      \"description\": \"A century ago, the grotesque giants known as Titans appeared and consumed all but a few thousand humans. The survivors took refuge behind giant walls. Today, the threat of the Titans is a distant memory, and a boy named Eren yearns to explore the world beyond Wall Maria. But what began as a childish dream will become an all-too-real nightmare when the Titans return and humanity is once again on the brink of extinction \u2026 Attack on Titan is the award-winning and New York Times-bestselling series that is the manga hit of the decade! Spawning the monster hit anime TV series of the same name, Attack on Titan has become a pop culture sensation. \\n\\n(Source: Kodansha Comics)\\n\\nVolume 3 contains the special story \\\"Rivai Heishichou\\\" (\u30ea\u30f4\u30a1\u30a4\u5175\u58eb\u9577, Captain Levi).\\nVolume 5 contains the side story \\\"Ilse no Techou\\\" (\u30a4\u30eb\u30bc\u306e\u624b\u5e33, Ilse's Notebook).\",\n      \"coverImageTopOffset\": 112,\n      \"titles\": {\n        \"ar\": \"\u0627\u0644\u0639\u0645\u0644\u0627\u0642 \u0627\u0644\u0645\u0647\u0627\u062c\u0645\",\n        \"en\": \"Attack on Titan\",\n        \"cs_cz\": \"\u00datok Tit\u00e1n\u016f\",\n        \"en_jp\": \"Shingeki no Kyojin\",\n        \"es_es\": \"Ataque a los Titanes\",\n        \"fa_ir\": \"\u062d\u0645\u0644\u0647 \u0628\u0647 \u062a\u0627\u06cc\u062a\u0627\u0646\",\n        \"fi_fi\": \"Titaanien sota\",\n        \"fr_fr\": \"L'Attaque des Titans\",\n        \"hr_hr\": \"Napad Titana\",\n        \"it_it\": \"L'attacco dei Giganti\",\n        \"ja_jp\": \"\u9032\u6483\u306e\u5de8\u4eba\",\n        \"ko_kr\": \"\uc9c4\uaca9\uc758 \uac70\uc778\",\n        \"pt_br\": \"Ataque dos Tit\u00e3s\",\n        \"ru_ru\": \"\u0410\u0442\u0430\u043a\u0430 \u043d\u0430 \u0442\u0438\u0442\u0430\u043d\u043e\u0432\",\n        \"th_th\": \"\u0e1c\u0e48\u0e32\u0e1e\u0e34\u0e20\u0e1e\u0e44\u0e17\u0e17\u0e31\u0e19\",\n        \"tr_tr\": \"Titana Sald\u0131r\u0131\",\n        \"vi_vn\": \"\u0110\u1ea1i Chi\u1ebfn Titan\",\n        \"zh_cn\": \"\u8fdb\u51fb\u7684\u5de8\u4eba\"\n      },\n      \"canonicalTitle\": \"Attack on Titan\",\n      \"abbreviatedTitles\": [\n        \"L'attaque sur les titans\",\n        \"\u0410\u0442\u0430\u043a\u0430 \u0442\u0438\u0442\u0430\u043d\u043e\u0432\",\n        \"\u06be\u06ce\u0631\u0634 \u0628\u06c6 \u0633\u06d5\u0631 \u0632\u06d5\u0628\u06d5\u0644\u0627\u062d\u06d5\u0643\u0627\u0646\",\n        \"\u9032\u64ca\u7684\u5de8\u4eba\",\n        \"SNK\",\n        \"AOT\",\n        \"Ilse no Techou\",\n        \"Rivai Heishichou\"\n      ]\n    }\n  }\n}\n</code></pre> <p>Kitsu returns data by following the Swagger API methodology exactly to the letter. You get self referential links, a ton of title information across several different headings, and even such things as the cover image offset. It returns average ratings, number of ratings per rating number, and even adjusted weighted rating. Kitsu returns a lot of data all at once, but the reality is that you don't need a lot of it. Lots of information you might want isn't even included. It's a separate call to get character data, a separate call to get episode data, a separate call to get staff and author data. So on and so forth. The benefits to using Kitsu would be the ease of creating a fluent application using the relationships data, the per language titles, and how many image options it has. It has images for covers, portraits and backgrounds in various sizes along with a definition of what each of those sizes actually is in pixels.</p> <p>As an example, let's say I want the French title for Attack on Titans... <pre><code>import pymoe\n\n# This is the manga Attack on Titan\nresult = pymoe.manga.get.kitsu.manga(14916)\n\n# This prints L'Attaque des Titans\nprint(result['data']['titles']['fr_fr'])\n</code></pre></p>"},{"location":"manga/mangaupdates/","title":"Pymoe.Manga - Mangaupdates","text":"<p>This is the documentation for the MangaUpdates module of Pymoe.Manga.</p>"},{"location":"manga/mangaupdates/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> manga, review, publisher, group, author, mangaReleaseFeed, releasesFeed, mangaByAuthor, groupsByManga, genres <code>SEARCH</code> categories, authors, groups, publishers, reviews, releases, manga"},{"location":"manga/mangaupdates/#get-methods","title":"GET Methods","text":"Endpoint Description <code>MANGA</code> Return information about a manga given an ID <code>REVIEW</code> Return information about a review given an ID <code>PUBLISHER</code> Return information about a publisher given an ID <code>GROUP</code> Return information about a group given an ID <code>AUTHOR</code> Return information about an author given an ID <code>MANGARELEASEFEED</code> Given a Manga ID, return the Manga's Release RSS Feed <code>RELEASESFEED</code> Return the sitewide releases RSS Feed <code>MANGABYAUTHOR</code> Given an Author ID, return all content they authored <code>GROUPSBYMANGA</code> Given a Manga ID, return all groups with releases for that Manga <code>GENRES</code> Return all genres along with stats for them (Manga tagged, etc)"},{"location":"manga/mangaupdates/#search-methods","title":"SEARCH Methods","text":"Endpoint Description <code>MANGA</code> Search for a Manga by Title <code>RELEASES</code> Search for releases that match a given Manga Title <code>REVIEWS</code> Given a Series ID return all reviews <code>PUBLISHERS</code> Search for a publisher <code>GROUPS</code> Search for a Group (Scanlator, etc) <code>AUTHORS</code> Search for an Author <code>CATEGORIES</code> Search for categories that match a term"},{"location":"manga/mangaupdates/#return-formatting","title":"Return Formatting","text":"<p>Thankfully, MangaUpdates's API does not have any special handling requirements. They only return the data requested, sometimes in a list and other times as a single json object. As an example, if we want the title of the Slam Dunk Manga it is...</p> <pre><code>import pymoe\n\nprint(pymoe.manga.get.mangaupdates.series(55665151734)['title'])\n</code></pre>"},{"location":"manga/mangaupdates/#some-notes","title":"Some Notes","text":""},{"location":"manga/mangaupdates/#groups","title":"Groups","text":"<p>Groups are defined by MangaUpdates as any Scanlators, Translators, Raw Providers, etc. Any group of people that uploads releases can be found under groups.</p>"},{"location":"manga/mangaupdates/#reviews","title":"Reviews","text":"<p>Reviews are not comments. So you might go to a page on MangaUpdates with a lot of User Comments (At the bottom of the page), but it may have no User Reviews. Comments appear at the bottom while Reviews appear in the series information underneath the User Reviews headline.</p> <p>Keep in mind that when you search for reviews you only get a small excerpt from the review. If you want the full body text for a review, you will have to get a review by ID. You can get review IDs by searching for reviews matching a series. Reviews are not included in the data returned when you get a series by ID.</p>"},{"location":"manga/mangaupdates/#the-feed-endpoints","title":"The Feed Endpoints","text":"<p>mangaReleaseFeed and releasesFeed both return XML data. They are simply convenience functions that build the required URL for you to get the XML data. I do not parse the XML data, it's returned as a string so you can push it into your XML parser of choice.</p> <p>Also, you should know that the RSS feeds returned by MangaUpdates have no way to filter the content that is new. It does not use etag, dates, or even a hash to indicate new content. So you're on your own when it comes to parsing for new content and the releasesFeed can return wildly different results even if you call for it back to back. It just depends on how fast releases happen. The Series Release Feed does however return ALL releases for that series even if it's a large XML document.</p>"},{"location":"manga/mangaupdates/#manga-by-author-and-groups-by-manga","title":"Manga By Author and Groups By Manga","text":"<p>Both of these take an ID and return either all manga related to that Author or all Groups with a release for that series ID. It does not return the groups releases. For that you want to use either the mangaReleaseFeed or the releases search endpoint.</p>"},{"location":"manga/start/","title":"Pymoe.Manga","text":"<p>What Does Default Mean?</p> <p>Whenever the term default is used, it refers to the top level functions available at pymoe.type.operation.endpoint. So <code>pymoe.anime.get.show</code> or <code>pymoe.manga.search.series</code>.</p> <p>This is the user guide for Pymoe.Manga and its submodules. This page will go over the default methods available at pymoe.manga.get and pymoe.manga.search. Further information on the specifics of each module are in their own documents.</p> Module Documentation Location <code>DEFAULT</code> This Page <code>ANILIST</code> Documentation <code>KITSU</code> Documentation <code>MANGAUPDATES</code> Documentation"},{"location":"manga/start/#the-default-methods","title":"The Default Methods","text":"<p>These default methods use Anilist.</p>"},{"location":"manga/start/#overview","title":"Overview","text":"Operation Endpoints <code>GET</code> manga, character <code>SEARCH</code> manga"},{"location":"manga/start/#get-methods","title":"GET Methods","text":"Endpoint Description Provider <code>MANGA</code> Return information about a manga given an ID Anilist <code>CHARACTER</code> Return information about a character given an ID Anilist <p>Some Examples</p> <pre><code># For Manga information from Anilist Manga ID 97722\n# This manga is Yami ni Hau Mono Lovecraft Kessakushuu\nprint(pymoe.manga.get.manga(97722))\n\n# For information on manga character 129928\n# This is Jin-U Seong, the MC from Solo Leveling\nprint(pymoe.manga.get.character(129928))\n</code></pre> <p>Return Formatting</p> <p>This is gone over in more detail in the specific documents, but this uses Anilist as the data provider. Anilist returns data that matches the GraphQL query used to build the request. In this case, the actual data is inside 'Media' in the returned dictionary.</p>"},{"location":"manga/start/#search-methods","title":"SEARCH Methods","text":"Endpoint Description Provider <code>manga</code> Search for the manga that matches the provided title Anilist <p>Some Examples</p> <pre><code># Search for the Manga named Toradora on Anilist\n# This will print the dictionary for each returned result\nfor item in pymoe.manga.search.manga(\"Toradora\"):\n    print(item)\n\n# Regarding the warning below, this is a way you could build a list with all the results in one list\nmyNewList = []\nfor item in pymoe.manga.search.manga(\"Toradora\"):\n    myNewList.append(item)\n</code></pre> <p>API Aware Lists</p> <p>When using a search module, we return a custom API aware list. This means that whether or not you use the generator structure, the result is a custom list that contains multiple dictionaries of data with each one representing a result from the search term. This list automatically refills itself with more results as you iterate through it. This does mean however that the list never contains the entirity of the results.</p>"}]}